Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program_content
Rule 1     program_content -> declaration program_content
Rule 2     program_content -> function_dec program_content
Rule 3     program_content -> function_body program_content
Rule 4     program_content -> program program_content
Rule 5     program_content -> declaration
Rule 6     program_content -> function_dec
Rule 7     program_content -> function_body
Rule 8     program_content -> program
Rule 9     function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON
Rule 10    arguments -> datatype pointer
Rule 11    arguments -> datatype pointer COMMA arguments
Rule 12    function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
Rule 13    return_stat -> RETURN pointer
Rule 14    return_stat -> RETURN NAME
Rule 15    function_call -> NAME LPAREN varlist RPAREN SEMICOLON
Rule 16    program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
Rule 17    function_content -> assignment_statement
Rule 18    function_content -> while_stat
Rule 19    function_content -> if_stat
Rule 20    function_content -> function_call
Rule 21    function_content -> assignment_statement function_content
Rule 22    function_content -> while_stat function_content
Rule 23    function_content -> if_stat function_content
Rule 24    function_content -> function_call function_content
Rule 25    function_content -> declaration
Rule 26    function_content -> declaration function_content
Rule 27    declaration -> datatype varlist SEMICOLON
Rule 28    datatype -> INT
Rule 29    datatype -> FLOAT
Rule 30    varlist -> NAME COMMA varlist
Rule 31    varlist -> NAME
Rule 32    varlist -> pointer COMMA varlist
Rule 33    varlist -> pointer
Rule 34    pointer -> ASTERISK pointer
Rule 35    pointer -> ASTERISK NAME
Rule 36    assignment_statement -> ID EQUAL RIGHT SEMICOLON
Rule 37    assignment_statement -> LEFT EQUAL expression SEMICOLON
Rule 38    assignment_statement -> ID EQUAL function_call
Rule 39    assignment_statement -> LEFT EQUAL function_call
Rule 40    ID -> NAME
Rule 41    LEFT -> ASTERISK var
Rule 42    RIGHT -> AMPERSAND var
Rule 43    expression -> expression PLUS expression
Rule 44    expression -> expression MINUS expression
Rule 45    expression -> expression ASTERISK expression
Rule 46    expression -> expression DIVIDE expression
Rule 47    expression -> var
Rule 48    expression -> NUMBERvar
Rule 49    expression -> LPAREN expression RPAREN
Rule 50    NUMBERvar -> NUMBER
Rule 51    var -> ASTERISK var
Rule 52    var -> AMPERSAND var
Rule 53    var -> NAME
Rule 54    expression -> MINUS expression
Rule 55    code_block -> if_stat
Rule 56    code_block -> while_stat
Rule 57    code_block -> assignment_statement
Rule 58    code_block -> LBRACE function_content RBRACE
Rule 59    while_stat -> WHILE LPAREN b_expression RPAREN code_block
Rule 60    if_stat -> IF LPAREN b_expression RPAREN code_block
Rule 61    if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block
Rule 62    b_expression -> expression sign1 expression
Rule 63    b_expression -> b_expression sign2 b_expression
Rule 64    b_expression -> LPAREN b_expression RPAREN
Rule 65    sign1 -> EQUALS
Rule 66    sign1 -> NOTEQUAL
Rule 67    sign1 -> GREATER
Rule 68    sign1 -> LESSER
Rule 69    sign1 -> GREATEREQ
Rule 70    sign1 -> LESSEREQ
Rule 71    sign2 -> LOGOR
Rule 72    sign2 -> LOGAND

Terminals, with rules where they appear

AMPERSAND            : 42 52
ASTERISK             : 34 35 41 45 51
COMMA                : 11 30 32
DIVIDE               : 46
ELSE                 : 61
EQUAL                : 36 37 38 39
EQUALS               : 65
FLOAT                : 29
GREATER              : 67
GREATEREQ            : 69
IF                   : 60 61
INT                  : 28
LBRACE               : 12 16 58
LESSER               : 68
LESSEREQ             : 70
LOGAND               : 72
LOGOR                : 71
LPAREN               : 9 12 15 16 49 59 60 61 64
MAIN                 : 16
MINUS                : 44 54
NAME                 : 14 15 30 31 35 40 53
NOTEQUAL             : 66
NUMBER               : 50
PLUS                 : 43
RBRACE               : 12 16 58
RETURN               : 13 14
RPAREN               : 9 12 15 16 49 59 60 61 64
SEMICOLON            : 9 15 27 36 37
VOID                 : 16
WHILE                : 59
error                : 

Nonterminals, with rules where they appear

ID                   : 36 38
LEFT                 : 37 39
NUMBERvar            : 48
RIGHT                : 36
arguments            : 9 11 12
assignment_statement : 17 21 57
b_expression         : 59 60 61 63 63 64
code_block           : 59 60 61 61
datatype             : 9 10 11 12 27
declaration          : 1 5 25 26
expression           : 37 43 43 44 44 45 45 46 46 49 54 62 62
function_body        : 3 7
function_call        : 20 24 38 39
function_content     : 12 16 21 22 23 24 26 58
function_dec         : 2 6
if_stat              : 19 23 55
pointer              : 9 10 11 12 13 32 33 34
program              : 4 8
program_content      : 1 2 3 4 0
return_stat          : 12
sign1                : 62
sign2                : 63
var                  : 41 42 47 51 52
varlist              : 15 27 30 32
while_stat           : 18 22 56

Parsing method: LALR

state 0

    (0) S' -> . program_content
    (1) program_content -> . declaration program_content
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . declaration
    (6) program_content -> . function_dec
    (7) program_content -> . function_body
    (8) program_content -> . program
    (27) declaration -> . datatype varlist SEMICOLON
    (9) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (12) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (16) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    VOID            shift and go to state 3
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    program_content                shift and go to state 1
    datatype                       shift and go to state 2
    function_dec                   shift and go to state 5
    program                        shift and go to state 6
    declaration                    shift and go to state 7
    function_body                  shift and go to state 8

state 1

    (0) S' -> program_content .



state 2

    (27) declaration -> datatype . varlist SEMICOLON
    (9) function_dec -> datatype . pointer LPAREN arguments RPAREN SEMICOLON
    (12) function_body -> datatype . pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (30) varlist -> . NAME COMMA varlist
    (31) varlist -> . NAME
    (32) varlist -> . pointer COMMA varlist
    (33) varlist -> . pointer
    (34) pointer -> . ASTERISK pointer
    (35) pointer -> . ASTERISK NAME

    NAME            shift and go to state 10
    ASTERISK        shift and go to state 11

    varlist                        shift and go to state 12
    pointer                        shift and go to state 13

state 3

    (16) program -> VOID . MAIN LPAREN RPAREN LBRACE function_content RBRACE

    MAIN            shift and go to state 14


state 4

    (29) datatype -> FLOAT .

    NAME            reduce using rule 29 (datatype -> FLOAT .)
    ASTERISK        reduce using rule 29 (datatype -> FLOAT .)


state 5

    (2) program_content -> function_dec . program_content
    (6) program_content -> function_dec .
    (1) program_content -> . declaration program_content
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . declaration
    (6) program_content -> . function_dec
    (7) program_content -> . function_body
    (8) program_content -> . program
    (27) declaration -> . datatype varlist SEMICOLON
    (9) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (12) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (16) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    $end            reduce using rule 6 (program_content -> function_dec .)
    VOID            shift and go to state 3
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    program_content                shift and go to state 15
    datatype                       shift and go to state 2
    function_dec                   shift and go to state 5
    program                        shift and go to state 6
    declaration                    shift and go to state 7
    function_body                  shift and go to state 8

state 6

    (4) program_content -> program . program_content
    (8) program_content -> program .
    (1) program_content -> . declaration program_content
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . declaration
    (6) program_content -> . function_dec
    (7) program_content -> . function_body
    (8) program_content -> . program
    (27) declaration -> . datatype varlist SEMICOLON
    (9) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (12) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (16) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    $end            reduce using rule 8 (program_content -> program .)
    VOID            shift and go to state 3
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    program_content                shift and go to state 16
    datatype                       shift and go to state 2
    function_dec                   shift and go to state 5
    program                        shift and go to state 6
    declaration                    shift and go to state 7
    function_body                  shift and go to state 8

state 7

    (1) program_content -> declaration . program_content
    (5) program_content -> declaration .
    (1) program_content -> . declaration program_content
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . declaration
    (6) program_content -> . function_dec
    (7) program_content -> . function_body
    (8) program_content -> . program
    (27) declaration -> . datatype varlist SEMICOLON
    (9) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (12) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (16) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    $end            reduce using rule 5 (program_content -> declaration .)
    VOID            shift and go to state 3
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    program_content                shift and go to state 17
    datatype                       shift and go to state 2
    function_dec                   shift and go to state 5
    program                        shift and go to state 6
    declaration                    shift and go to state 7
    function_body                  shift and go to state 8

state 8

    (3) program_content -> function_body . program_content
    (7) program_content -> function_body .
    (1) program_content -> . declaration program_content
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . declaration
    (6) program_content -> . function_dec
    (7) program_content -> . function_body
    (8) program_content -> . program
    (27) declaration -> . datatype varlist SEMICOLON
    (9) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (12) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (16) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    $end            reduce using rule 7 (program_content -> function_body .)
    VOID            shift and go to state 3
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    program_content                shift and go to state 18
    datatype                       shift and go to state 2
    function_dec                   shift and go to state 5
    program                        shift and go to state 6
    declaration                    shift and go to state 7
    function_body                  shift and go to state 8

state 9

    (28) datatype -> INT .

    NAME            reduce using rule 28 (datatype -> INT .)
    ASTERISK        reduce using rule 28 (datatype -> INT .)


state 10

    (30) varlist -> NAME . COMMA varlist
    (31) varlist -> NAME .

    COMMA           shift and go to state 19
    SEMICOLON       reduce using rule 31 (varlist -> NAME .)
    RPAREN          reduce using rule 31 (varlist -> NAME .)


state 11

    (34) pointer -> ASTERISK . pointer
    (35) pointer -> ASTERISK . NAME
    (34) pointer -> . ASTERISK pointer
    (35) pointer -> . ASTERISK NAME

    NAME            shift and go to state 21
    ASTERISK        shift and go to state 11

    pointer                        shift and go to state 20

state 12

    (27) declaration -> datatype varlist . SEMICOLON

    SEMICOLON       shift and go to state 22


state 13

    (9) function_dec -> datatype pointer . LPAREN arguments RPAREN SEMICOLON
    (12) function_body -> datatype pointer . LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (32) varlist -> pointer . COMMA varlist
    (33) varlist -> pointer .

    LPAREN          shift and go to state 24
    COMMA           shift and go to state 23
    SEMICOLON       reduce using rule 33 (varlist -> pointer .)


state 14

    (16) program -> VOID MAIN . LPAREN RPAREN LBRACE function_content RBRACE

    LPAREN          shift and go to state 25


state 15

    (2) program_content -> function_dec program_content .

    $end            reduce using rule 2 (program_content -> function_dec program_content .)


state 16

    (4) program_content -> program program_content .

    $end            reduce using rule 4 (program_content -> program program_content .)


state 17

    (1) program_content -> declaration program_content .

    $end            reduce using rule 1 (program_content -> declaration program_content .)


state 18

    (3) program_content -> function_body program_content .

    $end            reduce using rule 3 (program_content -> function_body program_content .)


state 19

    (30) varlist -> NAME COMMA . varlist
    (30) varlist -> . NAME COMMA varlist
    (31) varlist -> . NAME
    (32) varlist -> . pointer COMMA varlist
    (33) varlist -> . pointer
    (34) pointer -> . ASTERISK pointer
    (35) pointer -> . ASTERISK NAME

    NAME            shift and go to state 10
    ASTERISK        shift and go to state 11

    varlist                        shift and go to state 26
    pointer                        shift and go to state 27

state 20

    (34) pointer -> ASTERISK pointer .

    LPAREN          reduce using rule 34 (pointer -> ASTERISK pointer .)
    COMMA           reduce using rule 34 (pointer -> ASTERISK pointer .)
    SEMICOLON       reduce using rule 34 (pointer -> ASTERISK pointer .)
    RPAREN          reduce using rule 34 (pointer -> ASTERISK pointer .)
    RBRACE          reduce using rule 34 (pointer -> ASTERISK pointer .)


state 21

    (35) pointer -> ASTERISK NAME .

    LPAREN          reduce using rule 35 (pointer -> ASTERISK NAME .)
    COMMA           reduce using rule 35 (pointer -> ASTERISK NAME .)
    SEMICOLON       reduce using rule 35 (pointer -> ASTERISK NAME .)
    RPAREN          reduce using rule 35 (pointer -> ASTERISK NAME .)
    RBRACE          reduce using rule 35 (pointer -> ASTERISK NAME .)


state 22

    (27) declaration -> datatype varlist SEMICOLON .

    WHILE           reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)
    IF              reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)
    NAME            reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)
    ASTERISK        reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)
    INT             reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)
    FLOAT           reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)
    RBRACE          reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)
    VOID            reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)
    $end            reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)
    RETURN          reduce using rule 27 (declaration -> datatype varlist SEMICOLON .)


state 23

    (32) varlist -> pointer COMMA . varlist
    (30) varlist -> . NAME COMMA varlist
    (31) varlist -> . NAME
    (32) varlist -> . pointer COMMA varlist
    (33) varlist -> . pointer
    (34) pointer -> . ASTERISK pointer
    (35) pointer -> . ASTERISK NAME

    NAME            shift and go to state 10
    ASTERISK        shift and go to state 11

    varlist                        shift and go to state 28
    pointer                        shift and go to state 27

state 24

    (9) function_dec -> datatype pointer LPAREN . arguments RPAREN SEMICOLON
    (12) function_body -> datatype pointer LPAREN . arguments RPAREN LBRACE function_content return_stat RBRACE
    (10) arguments -> . datatype pointer
    (11) arguments -> . datatype pointer COMMA arguments
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    datatype                       shift and go to state 29
    arguments                      shift and go to state 30

state 25

    (16) program -> VOID MAIN LPAREN . RPAREN LBRACE function_content RBRACE

    RPAREN          shift and go to state 31


state 26

    (30) varlist -> NAME COMMA varlist .

    SEMICOLON       reduce using rule 30 (varlist -> NAME COMMA varlist .)
    RPAREN          reduce using rule 30 (varlist -> NAME COMMA varlist .)


state 27

    (32) varlist -> pointer . COMMA varlist
    (33) varlist -> pointer .

    COMMA           shift and go to state 23
    SEMICOLON       reduce using rule 33 (varlist -> pointer .)
    RPAREN          reduce using rule 33 (varlist -> pointer .)


state 28

    (32) varlist -> pointer COMMA varlist .

    SEMICOLON       reduce using rule 32 (varlist -> pointer COMMA varlist .)
    RPAREN          reduce using rule 32 (varlist -> pointer COMMA varlist .)


state 29

    (10) arguments -> datatype . pointer
    (11) arguments -> datatype . pointer COMMA arguments
    (34) pointer -> . ASTERISK pointer
    (35) pointer -> . ASTERISK NAME

    ASTERISK        shift and go to state 11

    pointer                        shift and go to state 32

state 30

    (9) function_dec -> datatype pointer LPAREN arguments . RPAREN SEMICOLON
    (12) function_body -> datatype pointer LPAREN arguments . RPAREN LBRACE function_content return_stat RBRACE

    RPAREN          shift and go to state 33


state 31

    (16) program -> VOID MAIN LPAREN RPAREN . LBRACE function_content RBRACE

    LBRACE          shift and go to state 34


state 32

    (10) arguments -> datatype pointer .
    (11) arguments -> datatype pointer . COMMA arguments

    RPAREN          reduce using rule 10 (arguments -> datatype pointer .)
    COMMA           shift and go to state 35


state 33

    (9) function_dec -> datatype pointer LPAREN arguments RPAREN . SEMICOLON
    (12) function_body -> datatype pointer LPAREN arguments RPAREN . LBRACE function_content return_stat RBRACE

    SEMICOLON       shift and go to state 37
    LBRACE          shift and go to state 36


state 34

    (16) program -> VOID MAIN LPAREN RPAREN LBRACE . function_content RBRACE
    (17) function_content -> . assignment_statement
    (18) function_content -> . while_stat
    (19) function_content -> . if_stat
    (20) function_content -> . function_call
    (21) function_content -> . assignment_statement function_content
    (22) function_content -> . while_stat function_content
    (23) function_content -> . if_stat function_content
    (24) function_content -> . function_call function_content
    (25) function_content -> . declaration
    (26) function_content -> . declaration function_content
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (27) declaration -> . datatype varlist SEMICOLON
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    WHILE           shift and go to state 40
    IF              shift and go to state 47
    NAME            shift and go to state 38
    ASTERISK        shift and go to state 44
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    function_content               shift and go to state 48
    while_stat                     shift and go to state 49
    if_stat                        shift and go to state 43
    assignment_statement           shift and go to state 41
    function_call                  shift and go to state 39
    datatype                       shift and go to state 50
    declaration                    shift and go to state 45
    ID                             shift and go to state 46
    LEFT                           shift and go to state 42

state 35

    (11) arguments -> datatype pointer COMMA . arguments
    (10) arguments -> . datatype pointer
    (11) arguments -> . datatype pointer COMMA arguments
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    datatype                       shift and go to state 29
    arguments                      shift and go to state 51

state 36

    (12) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE . function_content return_stat RBRACE
    (17) function_content -> . assignment_statement
    (18) function_content -> . while_stat
    (19) function_content -> . if_stat
    (20) function_content -> . function_call
    (21) function_content -> . assignment_statement function_content
    (22) function_content -> . while_stat function_content
    (23) function_content -> . if_stat function_content
    (24) function_content -> . function_call function_content
    (25) function_content -> . declaration
    (26) function_content -> . declaration function_content
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (27) declaration -> . datatype varlist SEMICOLON
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    WHILE           shift and go to state 40
    IF              shift and go to state 47
    NAME            shift and go to state 38
    ASTERISK        shift and go to state 44
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    while_stat                     shift and go to state 49
    function_content               shift and go to state 52
    datatype                       shift and go to state 50
    if_stat                        shift and go to state 43
    assignment_statement           shift and go to state 41
    function_call                  shift and go to state 39
    declaration                    shift and go to state 45
    ID                             shift and go to state 46
    LEFT                           shift and go to state 42

state 37

    (9) function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .

    VOID            reduce using rule 9 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)
    INT             reduce using rule 9 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)
    FLOAT           reduce using rule 9 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)
    $end            reduce using rule 9 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)


state 38

    (15) function_call -> NAME . LPAREN varlist RPAREN SEMICOLON
    (40) ID -> NAME .

    LPAREN          shift and go to state 53
    EQUAL           reduce using rule 40 (ID -> NAME .)


state 39

    (20) function_content -> function_call .
    (24) function_content -> function_call . function_content
    (17) function_content -> . assignment_statement
    (18) function_content -> . while_stat
    (19) function_content -> . if_stat
    (20) function_content -> . function_call
    (21) function_content -> . assignment_statement function_content
    (22) function_content -> . while_stat function_content
    (23) function_content -> . if_stat function_content
    (24) function_content -> . function_call function_content
    (25) function_content -> . declaration
    (26) function_content -> . declaration function_content
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (27) declaration -> . datatype varlist SEMICOLON
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    RBRACE          reduce using rule 20 (function_content -> function_call .)
    RETURN          reduce using rule 20 (function_content -> function_call .)
    WHILE           shift and go to state 40
    IF              shift and go to state 47
    NAME            shift and go to state 38
    ASTERISK        shift and go to state 44
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    function_content               shift and go to state 54
    while_stat                     shift and go to state 49
    if_stat                        shift and go to state 43
    assignment_statement           shift and go to state 41
    function_call                  shift and go to state 39
    datatype                       shift and go to state 50
    declaration                    shift and go to state 45
    ID                             shift and go to state 46
    LEFT                           shift and go to state 42

state 40

    (59) while_stat -> WHILE . LPAREN b_expression RPAREN code_block

    LPAREN          shift and go to state 55


state 41

    (17) function_content -> assignment_statement .
    (21) function_content -> assignment_statement . function_content
    (17) function_content -> . assignment_statement
    (18) function_content -> . while_stat
    (19) function_content -> . if_stat
    (20) function_content -> . function_call
    (21) function_content -> . assignment_statement function_content
    (22) function_content -> . while_stat function_content
    (23) function_content -> . if_stat function_content
    (24) function_content -> . function_call function_content
    (25) function_content -> . declaration
    (26) function_content -> . declaration function_content
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (27) declaration -> . datatype varlist SEMICOLON
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    RBRACE          reduce using rule 17 (function_content -> assignment_statement .)
    RETURN          reduce using rule 17 (function_content -> assignment_statement .)
    WHILE           shift and go to state 40
    IF              shift and go to state 47
    NAME            shift and go to state 38
    ASTERISK        shift and go to state 44
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    function_content               shift and go to state 56
    while_stat                     shift and go to state 49
    if_stat                        shift and go to state 43
    assignment_statement           shift and go to state 41
    function_call                  shift and go to state 39
    datatype                       shift and go to state 50
    declaration                    shift and go to state 45
    ID                             shift and go to state 46
    LEFT                           shift and go to state 42

state 42

    (37) assignment_statement -> LEFT . EQUAL expression SEMICOLON
    (39) assignment_statement -> LEFT . EQUAL function_call

    EQUAL           shift and go to state 57


state 43

    (19) function_content -> if_stat .
    (23) function_content -> if_stat . function_content
    (17) function_content -> . assignment_statement
    (18) function_content -> . while_stat
    (19) function_content -> . if_stat
    (20) function_content -> . function_call
    (21) function_content -> . assignment_statement function_content
    (22) function_content -> . while_stat function_content
    (23) function_content -> . if_stat function_content
    (24) function_content -> . function_call function_content
    (25) function_content -> . declaration
    (26) function_content -> . declaration function_content
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (27) declaration -> . datatype varlist SEMICOLON
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    RBRACE          reduce using rule 19 (function_content -> if_stat .)
    RETURN          reduce using rule 19 (function_content -> if_stat .)
    WHILE           shift and go to state 40
    IF              shift and go to state 47
    NAME            shift and go to state 38
    ASTERISK        shift and go to state 44
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    function_content               shift and go to state 58
    while_stat                     shift and go to state 49
    if_stat                        shift and go to state 43
    assignment_statement           shift and go to state 41
    function_call                  shift and go to state 39
    datatype                       shift and go to state 50
    declaration                    shift and go to state 45
    ID                             shift and go to state 46
    LEFT                           shift and go to state 42

state 44

    (41) LEFT -> ASTERISK . var
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME

    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62

    var                            shift and go to state 59

state 45

    (25) function_content -> declaration .
    (26) function_content -> declaration . function_content
    (17) function_content -> . assignment_statement
    (18) function_content -> . while_stat
    (19) function_content -> . if_stat
    (20) function_content -> . function_call
    (21) function_content -> . assignment_statement function_content
    (22) function_content -> . while_stat function_content
    (23) function_content -> . if_stat function_content
    (24) function_content -> . function_call function_content
    (25) function_content -> . declaration
    (26) function_content -> . declaration function_content
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (27) declaration -> . datatype varlist SEMICOLON
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    RBRACE          reduce using rule 25 (function_content -> declaration .)
    RETURN          reduce using rule 25 (function_content -> declaration .)
    WHILE           shift and go to state 40
    IF              shift and go to state 47
    NAME            shift and go to state 38
    ASTERISK        shift and go to state 44
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    function_content               shift and go to state 63
    while_stat                     shift and go to state 49
    if_stat                        shift and go to state 43
    assignment_statement           shift and go to state 41
    function_call                  shift and go to state 39
    datatype                       shift and go to state 50
    declaration                    shift and go to state 45
    ID                             shift and go to state 46
    LEFT                           shift and go to state 42

state 46

    (36) assignment_statement -> ID . EQUAL RIGHT SEMICOLON
    (38) assignment_statement -> ID . EQUAL function_call

    EQUAL           shift and go to state 64


state 47

    (60) if_stat -> IF . LPAREN b_expression RPAREN code_block
    (61) if_stat -> IF . LPAREN b_expression RPAREN code_block ELSE code_block

    LPAREN          shift and go to state 65


state 48

    (16) program -> VOID MAIN LPAREN RPAREN LBRACE function_content . RBRACE

    RBRACE          shift and go to state 66


state 49

    (18) function_content -> while_stat .
    (22) function_content -> while_stat . function_content
    (17) function_content -> . assignment_statement
    (18) function_content -> . while_stat
    (19) function_content -> . if_stat
    (20) function_content -> . function_call
    (21) function_content -> . assignment_statement function_content
    (22) function_content -> . while_stat function_content
    (23) function_content -> . if_stat function_content
    (24) function_content -> . function_call function_content
    (25) function_content -> . declaration
    (26) function_content -> . declaration function_content
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (27) declaration -> . datatype varlist SEMICOLON
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    RBRACE          reduce using rule 18 (function_content -> while_stat .)
    RETURN          reduce using rule 18 (function_content -> while_stat .)
    WHILE           shift and go to state 40
    IF              shift and go to state 47
    NAME            shift and go to state 38
    ASTERISK        shift and go to state 44
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    while_stat                     shift and go to state 49
    function_content               shift and go to state 67
    if_stat                        shift and go to state 43
    assignment_statement           shift and go to state 41
    function_call                  shift and go to state 39
    datatype                       shift and go to state 50
    declaration                    shift and go to state 45
    ID                             shift and go to state 46
    LEFT                           shift and go to state 42

state 50

    (27) declaration -> datatype . varlist SEMICOLON
    (30) varlist -> . NAME COMMA varlist
    (31) varlist -> . NAME
    (32) varlist -> . pointer COMMA varlist
    (33) varlist -> . pointer
    (34) pointer -> . ASTERISK pointer
    (35) pointer -> . ASTERISK NAME

    NAME            shift and go to state 10
    ASTERISK        shift and go to state 11

    varlist                        shift and go to state 12
    pointer                        shift and go to state 27

state 51

    (11) arguments -> datatype pointer COMMA arguments .

    RPAREN          reduce using rule 11 (arguments -> datatype pointer COMMA arguments .)


state 52

    (12) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content . return_stat RBRACE
    (13) return_stat -> . RETURN pointer
    (14) return_stat -> . RETURN NAME

    RETURN          shift and go to state 69

    return_stat                    shift and go to state 68

state 53

    (15) function_call -> NAME LPAREN . varlist RPAREN SEMICOLON
    (30) varlist -> . NAME COMMA varlist
    (31) varlist -> . NAME
    (32) varlist -> . pointer COMMA varlist
    (33) varlist -> . pointer
    (34) pointer -> . ASTERISK pointer
    (35) pointer -> . ASTERISK NAME

    NAME            shift and go to state 10
    ASTERISK        shift and go to state 11

    varlist                        shift and go to state 70
    pointer                        shift and go to state 27

state 54

    (24) function_content -> function_call function_content .

    RBRACE          reduce using rule 24 (function_content -> function_call function_content .)
    RETURN          reduce using rule 24 (function_content -> function_call function_content .)


state 55

    (59) while_stat -> WHILE LPAREN . b_expression RPAREN code_block
    (62) b_expression -> . expression sign1 expression
    (63) b_expression -> . b_expression sign2 b_expression
    (64) b_expression -> . LPAREN b_expression RPAREN
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 73
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    b_expression                   shift and go to state 72
    NUMBERvar                      shift and go to state 74
    var                            shift and go to state 75
    expression                     shift and go to state 76

state 56

    (21) function_content -> assignment_statement function_content .

    RBRACE          reduce using rule 21 (function_content -> assignment_statement function_content .)
    RETURN          reduce using rule 21 (function_content -> assignment_statement function_content .)


state 57

    (37) assignment_statement -> LEFT EQUAL . expression SEMICOLON
    (39) assignment_statement -> LEFT EQUAL . function_call
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 80
    MINUS           shift and go to state 77
    NAME            shift and go to state 78
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NUMBER          shift and go to state 71

    function_call                  shift and go to state 79
    NUMBERvar                      shift and go to state 74
    var                            shift and go to state 75
    expression                     shift and go to state 81

state 58

    (23) function_content -> if_stat function_content .

    RBRACE          reduce using rule 23 (function_content -> if_stat function_content .)
    RETURN          reduce using rule 23 (function_content -> if_stat function_content .)


state 59

    (41) LEFT -> ASTERISK var .

    EQUAL           reduce using rule 41 (LEFT -> ASTERISK var .)


state 60

    (52) var -> AMPERSAND . var
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME

    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62

    var                            shift and go to state 82

state 61

    (51) var -> ASTERISK . var
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME

    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62

    var                            shift and go to state 83

state 62

    (53) var -> NAME .

    PLUS            reduce using rule 53 (var -> NAME .)
    MINUS           reduce using rule 53 (var -> NAME .)
    ASTERISK        reduce using rule 53 (var -> NAME .)
    DIVIDE          reduce using rule 53 (var -> NAME .)
    EQUALS          reduce using rule 53 (var -> NAME .)
    NOTEQUAL        reduce using rule 53 (var -> NAME .)
    GREATER         reduce using rule 53 (var -> NAME .)
    LESSER          reduce using rule 53 (var -> NAME .)
    GREATEREQ       reduce using rule 53 (var -> NAME .)
    LESSEREQ        reduce using rule 53 (var -> NAME .)
    RPAREN          reduce using rule 53 (var -> NAME .)
    LOGOR           reduce using rule 53 (var -> NAME .)
    LOGAND          reduce using rule 53 (var -> NAME .)
    EQUAL           reduce using rule 53 (var -> NAME .)
    SEMICOLON       reduce using rule 53 (var -> NAME .)


state 63

    (26) function_content -> declaration function_content .

    RBRACE          reduce using rule 26 (function_content -> declaration function_content .)
    RETURN          reduce using rule 26 (function_content -> declaration function_content .)


state 64

    (36) assignment_statement -> ID EQUAL . RIGHT SEMICOLON
    (38) assignment_statement -> ID EQUAL . function_call
    (42) RIGHT -> . AMPERSAND var
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON

    AMPERSAND       shift and go to state 87
    NAME            shift and go to state 85

    RIGHT                          shift and go to state 84
    function_call                  shift and go to state 86

state 65

    (60) if_stat -> IF LPAREN . b_expression RPAREN code_block
    (61) if_stat -> IF LPAREN . b_expression RPAREN code_block ELSE code_block
    (62) b_expression -> . expression sign1 expression
    (63) b_expression -> . b_expression sign2 b_expression
    (64) b_expression -> . LPAREN b_expression RPAREN
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 73
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    b_expression                   shift and go to state 88
    NUMBERvar                      shift and go to state 74
    var                            shift and go to state 75
    expression                     shift and go to state 76

state 66

    (16) program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .

    VOID            reduce using rule 16 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)
    INT             reduce using rule 16 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)
    FLOAT           reduce using rule 16 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)
    $end            reduce using rule 16 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)


state 67

    (22) function_content -> while_stat function_content .

    RBRACE          reduce using rule 22 (function_content -> while_stat function_content .)
    RETURN          reduce using rule 22 (function_content -> while_stat function_content .)


state 68

    (12) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat . RBRACE

    RBRACE          shift and go to state 89


state 69

    (13) return_stat -> RETURN . pointer
    (14) return_stat -> RETURN . NAME
    (34) pointer -> . ASTERISK pointer
    (35) pointer -> . ASTERISK NAME

    NAME            shift and go to state 91
    ASTERISK        shift and go to state 11

    pointer                        shift and go to state 90

state 70

    (15) function_call -> NAME LPAREN varlist . RPAREN SEMICOLON

    RPAREN          shift and go to state 92


state 71

    (50) NUMBERvar -> NUMBER .

    PLUS            reduce using rule 50 (NUMBERvar -> NUMBER .)
    MINUS           reduce using rule 50 (NUMBERvar -> NUMBER .)
    ASTERISK        reduce using rule 50 (NUMBERvar -> NUMBER .)
    DIVIDE          reduce using rule 50 (NUMBERvar -> NUMBER .)
    EQUALS          reduce using rule 50 (NUMBERvar -> NUMBER .)
    NOTEQUAL        reduce using rule 50 (NUMBERvar -> NUMBER .)
    GREATER         reduce using rule 50 (NUMBERvar -> NUMBER .)
    LESSER          reduce using rule 50 (NUMBERvar -> NUMBER .)
    GREATEREQ       reduce using rule 50 (NUMBERvar -> NUMBER .)
    LESSEREQ        reduce using rule 50 (NUMBERvar -> NUMBER .)
    SEMICOLON       reduce using rule 50 (NUMBERvar -> NUMBER .)
    RPAREN          reduce using rule 50 (NUMBERvar -> NUMBER .)
    LOGOR           reduce using rule 50 (NUMBERvar -> NUMBER .)
    LOGAND          reduce using rule 50 (NUMBERvar -> NUMBER .)


state 72

    (59) while_stat -> WHILE LPAREN b_expression . RPAREN code_block
    (63) b_expression -> b_expression . sign2 b_expression
    (71) sign2 -> . LOGOR
    (72) sign2 -> . LOGAND

    RPAREN          shift and go to state 94
    LOGOR           shift and go to state 93
    LOGAND          shift and go to state 95

    sign2                          shift and go to state 96

state 73

    (64) b_expression -> LPAREN . b_expression RPAREN
    (49) expression -> LPAREN . expression RPAREN
    (62) b_expression -> . expression sign1 expression
    (63) b_expression -> . b_expression sign2 b_expression
    (64) b_expression -> . LPAREN b_expression RPAREN
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 73
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    b_expression                   shift and go to state 97
    NUMBERvar                      shift and go to state 74
    var                            shift and go to state 75
    expression                     shift and go to state 98

state 74

    (48) expression -> NUMBERvar .

    PLUS            reduce using rule 48 (expression -> NUMBERvar .)
    MINUS           reduce using rule 48 (expression -> NUMBERvar .)
    ASTERISK        reduce using rule 48 (expression -> NUMBERvar .)
    DIVIDE          reduce using rule 48 (expression -> NUMBERvar .)
    EQUALS          reduce using rule 48 (expression -> NUMBERvar .)
    NOTEQUAL        reduce using rule 48 (expression -> NUMBERvar .)
    GREATER         reduce using rule 48 (expression -> NUMBERvar .)
    LESSER          reduce using rule 48 (expression -> NUMBERvar .)
    GREATEREQ       reduce using rule 48 (expression -> NUMBERvar .)
    LESSEREQ        reduce using rule 48 (expression -> NUMBERvar .)
    SEMICOLON       reduce using rule 48 (expression -> NUMBERvar .)
    RPAREN          reduce using rule 48 (expression -> NUMBERvar .)
    LOGOR           reduce using rule 48 (expression -> NUMBERvar .)
    LOGAND          reduce using rule 48 (expression -> NUMBERvar .)


state 75

    (47) expression -> var .

    PLUS            reduce using rule 47 (expression -> var .)
    MINUS           reduce using rule 47 (expression -> var .)
    ASTERISK        reduce using rule 47 (expression -> var .)
    DIVIDE          reduce using rule 47 (expression -> var .)
    EQUALS          reduce using rule 47 (expression -> var .)
    NOTEQUAL        reduce using rule 47 (expression -> var .)
    GREATER         reduce using rule 47 (expression -> var .)
    LESSER          reduce using rule 47 (expression -> var .)
    GREATEREQ       reduce using rule 47 (expression -> var .)
    LESSEREQ        reduce using rule 47 (expression -> var .)
    SEMICOLON       reduce using rule 47 (expression -> var .)
    RPAREN          reduce using rule 47 (expression -> var .)
    LOGOR           reduce using rule 47 (expression -> var .)
    LOGAND          reduce using rule 47 (expression -> var .)


state 76

    (62) b_expression -> expression . sign1 expression
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression
    (65) sign1 -> . EQUALS
    (66) sign1 -> . NOTEQUAL
    (67) sign1 -> . GREATER
    (68) sign1 -> . LESSER
    (69) sign1 -> . GREATEREQ
    (70) sign1 -> . LESSEREQ

    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    ASTERISK        shift and go to state 102
    DIVIDE          shift and go to state 100
    EQUALS          shift and go to state 103
    NOTEQUAL        shift and go to state 99
    GREATER         shift and go to state 109
    LESSER          shift and go to state 104
    GREATEREQ       shift and go to state 105
    LESSEREQ        shift and go to state 101

    sign1                          shift and go to state 107

state 77

    (54) expression -> MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 80
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    var                            shift and go to state 75
    expression                     shift and go to state 110
    NUMBERvar                      shift and go to state 74

state 78

    (15) function_call -> NAME . LPAREN varlist RPAREN SEMICOLON
    (53) var -> NAME .

    LPAREN          shift and go to state 53
    SEMICOLON       reduce using rule 53 (var -> NAME .)
    PLUS            reduce using rule 53 (var -> NAME .)
    MINUS           reduce using rule 53 (var -> NAME .)
    ASTERISK        reduce using rule 53 (var -> NAME .)
    DIVIDE          reduce using rule 53 (var -> NAME .)


state 79

    (39) assignment_statement -> LEFT EQUAL function_call .

    WHILE           reduce using rule 39 (assignment_statement -> LEFT EQUAL function_call .)
    IF              reduce using rule 39 (assignment_statement -> LEFT EQUAL function_call .)
    NAME            reduce using rule 39 (assignment_statement -> LEFT EQUAL function_call .)
    ASTERISK        reduce using rule 39 (assignment_statement -> LEFT EQUAL function_call .)
    INT             reduce using rule 39 (assignment_statement -> LEFT EQUAL function_call .)
    FLOAT           reduce using rule 39 (assignment_statement -> LEFT EQUAL function_call .)
    RBRACE          reduce using rule 39 (assignment_statement -> LEFT EQUAL function_call .)
    RETURN          reduce using rule 39 (assignment_statement -> LEFT EQUAL function_call .)
    ELSE            reduce using rule 39 (assignment_statement -> LEFT EQUAL function_call .)


state 80

    (49) expression -> LPAREN . expression RPAREN
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 80
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    var                            shift and go to state 75
    expression                     shift and go to state 111
    NUMBERvar                      shift and go to state 74

state 81

    (37) assignment_statement -> LEFT EQUAL expression . SEMICOLON
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 112
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    ASTERISK        shift and go to state 102
    DIVIDE          shift and go to state 100


state 82

    (52) var -> AMPERSAND var .

    PLUS            reduce using rule 52 (var -> AMPERSAND var .)
    MINUS           reduce using rule 52 (var -> AMPERSAND var .)
    ASTERISK        reduce using rule 52 (var -> AMPERSAND var .)
    DIVIDE          reduce using rule 52 (var -> AMPERSAND var .)
    EQUALS          reduce using rule 52 (var -> AMPERSAND var .)
    NOTEQUAL        reduce using rule 52 (var -> AMPERSAND var .)
    GREATER         reduce using rule 52 (var -> AMPERSAND var .)
    LESSER          reduce using rule 52 (var -> AMPERSAND var .)
    GREATEREQ       reduce using rule 52 (var -> AMPERSAND var .)
    LESSEREQ        reduce using rule 52 (var -> AMPERSAND var .)
    RPAREN          reduce using rule 52 (var -> AMPERSAND var .)
    LOGOR           reduce using rule 52 (var -> AMPERSAND var .)
    LOGAND          reduce using rule 52 (var -> AMPERSAND var .)
    EQUAL           reduce using rule 52 (var -> AMPERSAND var .)
    SEMICOLON       reduce using rule 52 (var -> AMPERSAND var .)


state 83

    (51) var -> ASTERISK var .

    PLUS            reduce using rule 51 (var -> ASTERISK var .)
    MINUS           reduce using rule 51 (var -> ASTERISK var .)
    ASTERISK        reduce using rule 51 (var -> ASTERISK var .)
    DIVIDE          reduce using rule 51 (var -> ASTERISK var .)
    EQUALS          reduce using rule 51 (var -> ASTERISK var .)
    NOTEQUAL        reduce using rule 51 (var -> ASTERISK var .)
    GREATER         reduce using rule 51 (var -> ASTERISK var .)
    LESSER          reduce using rule 51 (var -> ASTERISK var .)
    GREATEREQ       reduce using rule 51 (var -> ASTERISK var .)
    LESSEREQ        reduce using rule 51 (var -> ASTERISK var .)
    RPAREN          reduce using rule 51 (var -> ASTERISK var .)
    LOGOR           reduce using rule 51 (var -> ASTERISK var .)
    LOGAND          reduce using rule 51 (var -> ASTERISK var .)
    EQUAL           reduce using rule 51 (var -> ASTERISK var .)
    SEMICOLON       reduce using rule 51 (var -> ASTERISK var .)


state 84

    (36) assignment_statement -> ID EQUAL RIGHT . SEMICOLON

    SEMICOLON       shift and go to state 113


state 85

    (15) function_call -> NAME . LPAREN varlist RPAREN SEMICOLON

    LPAREN          shift and go to state 53


state 86

    (38) assignment_statement -> ID EQUAL function_call .

    WHILE           reduce using rule 38 (assignment_statement -> ID EQUAL function_call .)
    IF              reduce using rule 38 (assignment_statement -> ID EQUAL function_call .)
    NAME            reduce using rule 38 (assignment_statement -> ID EQUAL function_call .)
    ASTERISK        reduce using rule 38 (assignment_statement -> ID EQUAL function_call .)
    INT             reduce using rule 38 (assignment_statement -> ID EQUAL function_call .)
    FLOAT           reduce using rule 38 (assignment_statement -> ID EQUAL function_call .)
    RBRACE          reduce using rule 38 (assignment_statement -> ID EQUAL function_call .)
    RETURN          reduce using rule 38 (assignment_statement -> ID EQUAL function_call .)
    ELSE            reduce using rule 38 (assignment_statement -> ID EQUAL function_call .)


state 87

    (42) RIGHT -> AMPERSAND . var
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME

    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62

    var                            shift and go to state 114

state 88

    (60) if_stat -> IF LPAREN b_expression . RPAREN code_block
    (61) if_stat -> IF LPAREN b_expression . RPAREN code_block ELSE code_block
    (63) b_expression -> b_expression . sign2 b_expression
    (71) sign2 -> . LOGOR
    (72) sign2 -> . LOGAND

    RPAREN          shift and go to state 115
    LOGOR           shift and go to state 93
    LOGAND          shift and go to state 95

    sign2                          shift and go to state 96

state 89

    (12) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .

    VOID            reduce using rule 12 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    INT             reduce using rule 12 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    FLOAT           reduce using rule 12 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    $end            reduce using rule 12 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)


state 90

    (13) return_stat -> RETURN pointer .

    RBRACE          reduce using rule 13 (return_stat -> RETURN pointer .)


state 91

    (14) return_stat -> RETURN NAME .

    RBRACE          reduce using rule 14 (return_stat -> RETURN NAME .)


state 92

    (15) function_call -> NAME LPAREN varlist RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 116


state 93

    (71) sign2 -> LOGOR .

    LPAREN          reduce using rule 71 (sign2 -> LOGOR .)
    MINUS           reduce using rule 71 (sign2 -> LOGOR .)
    ASTERISK        reduce using rule 71 (sign2 -> LOGOR .)
    AMPERSAND       reduce using rule 71 (sign2 -> LOGOR .)
    NAME            reduce using rule 71 (sign2 -> LOGOR .)
    NUMBER          reduce using rule 71 (sign2 -> LOGOR .)


state 94

    (59) while_stat -> WHILE LPAREN b_expression RPAREN . code_block
    (55) code_block -> . if_stat
    (56) code_block -> . while_stat
    (57) code_block -> . assignment_statement
    (58) code_block -> . LBRACE function_content RBRACE
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var

    LBRACE          shift and go to state 117
    IF              shift and go to state 47
    WHILE           shift and go to state 40
    NAME            shift and go to state 120
    ASTERISK        shift and go to state 44

    code_block                     shift and go to state 121
    while_stat                     shift and go to state 122
    if_stat                        shift and go to state 119
    assignment_statement           shift and go to state 118
    LEFT                           shift and go to state 42
    ID                             shift and go to state 46

state 95

    (72) sign2 -> LOGAND .

    LPAREN          reduce using rule 72 (sign2 -> LOGAND .)
    MINUS           reduce using rule 72 (sign2 -> LOGAND .)
    ASTERISK        reduce using rule 72 (sign2 -> LOGAND .)
    AMPERSAND       reduce using rule 72 (sign2 -> LOGAND .)
    NAME            reduce using rule 72 (sign2 -> LOGAND .)
    NUMBER          reduce using rule 72 (sign2 -> LOGAND .)


state 96

    (63) b_expression -> b_expression sign2 . b_expression
    (62) b_expression -> . expression sign1 expression
    (63) b_expression -> . b_expression sign2 b_expression
    (64) b_expression -> . LPAREN b_expression RPAREN
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 73
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    b_expression                   shift and go to state 123
    NUMBERvar                      shift and go to state 74
    var                            shift and go to state 75
    expression                     shift and go to state 76

state 97

    (64) b_expression -> LPAREN b_expression . RPAREN
    (63) b_expression -> b_expression . sign2 b_expression
    (71) sign2 -> . LOGOR
    (72) sign2 -> . LOGAND

    RPAREN          shift and go to state 124
    LOGOR           shift and go to state 93
    LOGAND          shift and go to state 95

    sign2                          shift and go to state 96

state 98

    (49) expression -> LPAREN expression . RPAREN
    (62) b_expression -> expression . sign1 expression
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression
    (65) sign1 -> . EQUALS
    (66) sign1 -> . NOTEQUAL
    (67) sign1 -> . GREATER
    (68) sign1 -> . LESSER
    (69) sign1 -> . GREATEREQ
    (70) sign1 -> . LESSEREQ

    RPAREN          shift and go to state 125
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    ASTERISK        shift and go to state 102
    DIVIDE          shift and go to state 100
    EQUALS          shift and go to state 103
    NOTEQUAL        shift and go to state 99
    GREATER         shift and go to state 109
    LESSER          shift and go to state 104
    GREATEREQ       shift and go to state 105
    LESSEREQ        shift and go to state 101

    sign1                          shift and go to state 107

state 99

    (66) sign1 -> NOTEQUAL .

    LPAREN          reduce using rule 66 (sign1 -> NOTEQUAL .)
    MINUS           reduce using rule 66 (sign1 -> NOTEQUAL .)
    ASTERISK        reduce using rule 66 (sign1 -> NOTEQUAL .)
    AMPERSAND       reduce using rule 66 (sign1 -> NOTEQUAL .)
    NAME            reduce using rule 66 (sign1 -> NOTEQUAL .)
    NUMBER          reduce using rule 66 (sign1 -> NOTEQUAL .)


state 100

    (46) expression -> expression DIVIDE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 80
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    var                            shift and go to state 75
    expression                     shift and go to state 126
    NUMBERvar                      shift and go to state 74

state 101

    (70) sign1 -> LESSEREQ .

    LPAREN          reduce using rule 70 (sign1 -> LESSEREQ .)
    MINUS           reduce using rule 70 (sign1 -> LESSEREQ .)
    ASTERISK        reduce using rule 70 (sign1 -> LESSEREQ .)
    AMPERSAND       reduce using rule 70 (sign1 -> LESSEREQ .)
    NAME            reduce using rule 70 (sign1 -> LESSEREQ .)
    NUMBER          reduce using rule 70 (sign1 -> LESSEREQ .)


state 102

    (45) expression -> expression ASTERISK . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 80
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    var                            shift and go to state 75
    expression                     shift and go to state 127
    NUMBERvar                      shift and go to state 74

state 103

    (65) sign1 -> EQUALS .

    LPAREN          reduce using rule 65 (sign1 -> EQUALS .)
    MINUS           reduce using rule 65 (sign1 -> EQUALS .)
    ASTERISK        reduce using rule 65 (sign1 -> EQUALS .)
    AMPERSAND       reduce using rule 65 (sign1 -> EQUALS .)
    NAME            reduce using rule 65 (sign1 -> EQUALS .)
    NUMBER          reduce using rule 65 (sign1 -> EQUALS .)


state 104

    (68) sign1 -> LESSER .

    LPAREN          reduce using rule 68 (sign1 -> LESSER .)
    MINUS           reduce using rule 68 (sign1 -> LESSER .)
    ASTERISK        reduce using rule 68 (sign1 -> LESSER .)
    AMPERSAND       reduce using rule 68 (sign1 -> LESSER .)
    NAME            reduce using rule 68 (sign1 -> LESSER .)
    NUMBER          reduce using rule 68 (sign1 -> LESSER .)


state 105

    (69) sign1 -> GREATEREQ .

    LPAREN          reduce using rule 69 (sign1 -> GREATEREQ .)
    MINUS           reduce using rule 69 (sign1 -> GREATEREQ .)
    ASTERISK        reduce using rule 69 (sign1 -> GREATEREQ .)
    AMPERSAND       reduce using rule 69 (sign1 -> GREATEREQ .)
    NAME            reduce using rule 69 (sign1 -> GREATEREQ .)
    NUMBER          reduce using rule 69 (sign1 -> GREATEREQ .)


state 106

    (43) expression -> expression PLUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 80
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    var                            shift and go to state 75
    expression                     shift and go to state 128
    NUMBERvar                      shift and go to state 74

state 107

    (62) b_expression -> expression sign1 . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 80
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    var                            shift and go to state 75
    expression                     shift and go to state 129
    NUMBERvar                      shift and go to state 74

state 108

    (44) expression -> expression MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression ASTERISK expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . var
    (48) expression -> . NUMBERvar
    (49) expression -> . LPAREN expression RPAREN
    (54) expression -> . MINUS expression
    (51) var -> . ASTERISK var
    (52) var -> . AMPERSAND var
    (53) var -> . NAME
    (50) NUMBERvar -> . NUMBER

    LPAREN          shift and go to state 80
    MINUS           shift and go to state 77
    ASTERISK        shift and go to state 61
    AMPERSAND       shift and go to state 60
    NAME            shift and go to state 62
    NUMBER          shift and go to state 71

    var                            shift and go to state 75
    expression                     shift and go to state 130
    NUMBERvar                      shift and go to state 74

state 109

    (67) sign1 -> GREATER .

    LPAREN          reduce using rule 67 (sign1 -> GREATER .)
    MINUS           reduce using rule 67 (sign1 -> GREATER .)
    ASTERISK        reduce using rule 67 (sign1 -> GREATER .)
    AMPERSAND       reduce using rule 67 (sign1 -> GREATER .)
    NAME            reduce using rule 67 (sign1 -> GREATER .)
    NUMBER          reduce using rule 67 (sign1 -> GREATER .)


state 110

    (54) expression -> MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 54 (expression -> MINUS expression .)
    MINUS           reduce using rule 54 (expression -> MINUS expression .)
    ASTERISK        reduce using rule 54 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 54 (expression -> MINUS expression .)
    EQUALS          reduce using rule 54 (expression -> MINUS expression .)
    NOTEQUAL        reduce using rule 54 (expression -> MINUS expression .)
    GREATER         reduce using rule 54 (expression -> MINUS expression .)
    LESSER          reduce using rule 54 (expression -> MINUS expression .)
    GREATEREQ       reduce using rule 54 (expression -> MINUS expression .)
    LESSEREQ        reduce using rule 54 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 54 (expression -> MINUS expression .)
    RPAREN          reduce using rule 54 (expression -> MINUS expression .)
    LOGOR           reduce using rule 54 (expression -> MINUS expression .)
    LOGAND          reduce using rule 54 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]
  ! ASTERISK        [ shift and go to state 102 ]
  ! DIVIDE          [ shift and go to state 100 ]


state 111

    (49) expression -> LPAREN expression . RPAREN
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 125
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    ASTERISK        shift and go to state 102
    DIVIDE          shift and go to state 100


state 112

    (37) assignment_statement -> LEFT EQUAL expression SEMICOLON .

    WHILE           reduce using rule 37 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    IF              reduce using rule 37 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    NAME            reduce using rule 37 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    ASTERISK        reduce using rule 37 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    INT             reduce using rule 37 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 37 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 37 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 37 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    ELSE            reduce using rule 37 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)


state 113

    (36) assignment_statement -> ID EQUAL RIGHT SEMICOLON .

    WHILE           reduce using rule 36 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    IF              reduce using rule 36 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    NAME            reduce using rule 36 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    ASTERISK        reduce using rule 36 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    INT             reduce using rule 36 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    FLOAT           reduce using rule 36 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    RBRACE          reduce using rule 36 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    RETURN          reduce using rule 36 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    ELSE            reduce using rule 36 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)


state 114

    (42) RIGHT -> AMPERSAND var .

    SEMICOLON       reduce using rule 42 (RIGHT -> AMPERSAND var .)


state 115

    (60) if_stat -> IF LPAREN b_expression RPAREN . code_block
    (61) if_stat -> IF LPAREN b_expression RPAREN . code_block ELSE code_block
    (55) code_block -> . if_stat
    (56) code_block -> . while_stat
    (57) code_block -> . assignment_statement
    (58) code_block -> . LBRACE function_content RBRACE
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var

    LBRACE          shift and go to state 117
    IF              shift and go to state 47
    WHILE           shift and go to state 40
    NAME            shift and go to state 120
    ASTERISK        shift and go to state 44

    code_block                     shift and go to state 131
    while_stat                     shift and go to state 122
    if_stat                        shift and go to state 119
    assignment_statement           shift and go to state 118
    LEFT                           shift and go to state 42
    ID                             shift and go to state 46

state 116

    (15) function_call -> NAME LPAREN varlist RPAREN SEMICOLON .

    WHILE           reduce using rule 15 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    IF              reduce using rule 15 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    NAME            reduce using rule 15 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    ASTERISK        reduce using rule 15 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    INT             reduce using rule 15 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    FLOAT           reduce using rule 15 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    RBRACE          reduce using rule 15 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    RETURN          reduce using rule 15 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    ELSE            reduce using rule 15 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)


state 117

    (58) code_block -> LBRACE . function_content RBRACE
    (17) function_content -> . assignment_statement
    (18) function_content -> . while_stat
    (19) function_content -> . if_stat
    (20) function_content -> . function_call
    (21) function_content -> . assignment_statement function_content
    (22) function_content -> . while_stat function_content
    (23) function_content -> . if_stat function_content
    (24) function_content -> . function_call function_content
    (25) function_content -> . declaration
    (26) function_content -> . declaration function_content
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (15) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (27) declaration -> . datatype varlist SEMICOLON
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var
    (28) datatype -> . INT
    (29) datatype -> . FLOAT

    WHILE           shift and go to state 40
    IF              shift and go to state 47
    NAME            shift and go to state 38
    ASTERISK        shift and go to state 44
    INT             shift and go to state 9
    FLOAT           shift and go to state 4

    function_content               shift and go to state 132
    while_stat                     shift and go to state 49
    if_stat                        shift and go to state 43
    assignment_statement           shift and go to state 41
    function_call                  shift and go to state 39
    datatype                       shift and go to state 50
    declaration                    shift and go to state 45
    ID                             shift and go to state 46
    LEFT                           shift and go to state 42

state 118

    (57) code_block -> assignment_statement .

    WHILE           reduce using rule 57 (code_block -> assignment_statement .)
    IF              reduce using rule 57 (code_block -> assignment_statement .)
    NAME            reduce using rule 57 (code_block -> assignment_statement .)
    ASTERISK        reduce using rule 57 (code_block -> assignment_statement .)
    INT             reduce using rule 57 (code_block -> assignment_statement .)
    FLOAT           reduce using rule 57 (code_block -> assignment_statement .)
    RBRACE          reduce using rule 57 (code_block -> assignment_statement .)
    RETURN          reduce using rule 57 (code_block -> assignment_statement .)
    ELSE            reduce using rule 57 (code_block -> assignment_statement .)


state 119

    (55) code_block -> if_stat .

    WHILE           reduce using rule 55 (code_block -> if_stat .)
    IF              reduce using rule 55 (code_block -> if_stat .)
    NAME            reduce using rule 55 (code_block -> if_stat .)
    ASTERISK        reduce using rule 55 (code_block -> if_stat .)
    INT             reduce using rule 55 (code_block -> if_stat .)
    FLOAT           reduce using rule 55 (code_block -> if_stat .)
    RBRACE          reduce using rule 55 (code_block -> if_stat .)
    RETURN          reduce using rule 55 (code_block -> if_stat .)
    ELSE            reduce using rule 55 (code_block -> if_stat .)


state 120

    (40) ID -> NAME .

    EQUAL           reduce using rule 40 (ID -> NAME .)


state 121

    (59) while_stat -> WHILE LPAREN b_expression RPAREN code_block .

    WHILE           reduce using rule 59 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    IF              reduce using rule 59 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    NAME            reduce using rule 59 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    ASTERISK        reduce using rule 59 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    INT             reduce using rule 59 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    FLOAT           reduce using rule 59 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    RBRACE          reduce using rule 59 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    RETURN          reduce using rule 59 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    ELSE            reduce using rule 59 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)


state 122

    (56) code_block -> while_stat .

    WHILE           reduce using rule 56 (code_block -> while_stat .)
    IF              reduce using rule 56 (code_block -> while_stat .)
    NAME            reduce using rule 56 (code_block -> while_stat .)
    ASTERISK        reduce using rule 56 (code_block -> while_stat .)
    INT             reduce using rule 56 (code_block -> while_stat .)
    FLOAT           reduce using rule 56 (code_block -> while_stat .)
    RBRACE          reduce using rule 56 (code_block -> while_stat .)
    RETURN          reduce using rule 56 (code_block -> while_stat .)
    ELSE            reduce using rule 56 (code_block -> while_stat .)


state 123

    (63) b_expression -> b_expression sign2 b_expression .
    (63) b_expression -> b_expression . sign2 b_expression
    (71) sign2 -> . LOGOR
    (72) sign2 -> . LOGAND

  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
    RPAREN          reduce using rule 63 (b_expression -> b_expression sign2 b_expression .)
    LOGOR           shift and go to state 93
    LOGAND          shift and go to state 95

  ! LOGOR           [ reduce using rule 63 (b_expression -> b_expression sign2 b_expression .) ]
  ! LOGAND          [ reduce using rule 63 (b_expression -> b_expression sign2 b_expression .) ]

    sign2                          shift and go to state 96

state 124

    (64) b_expression -> LPAREN b_expression RPAREN .

    LOGOR           reduce using rule 64 (b_expression -> LPAREN b_expression RPAREN .)
    LOGAND          reduce using rule 64 (b_expression -> LPAREN b_expression RPAREN .)
    RPAREN          reduce using rule 64 (b_expression -> LPAREN b_expression RPAREN .)


state 125

    (49) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    ASTERISK        reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    EQUALS          reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    LESSER          reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    LESSEREQ        reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    LOGOR           reduce using rule 49 (expression -> LPAREN expression RPAREN .)
    LOGAND          reduce using rule 49 (expression -> LPAREN expression RPAREN .)


state 126

    (46) expression -> expression DIVIDE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 46 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 46 (expression -> expression DIVIDE expression .)
    ASTERISK        reduce using rule 46 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 46 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 46 (expression -> expression DIVIDE expression .)
    NOTEQUAL        reduce using rule 46 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 46 (expression -> expression DIVIDE expression .)
    LESSER          reduce using rule 46 (expression -> expression DIVIDE expression .)
    GREATEREQ       reduce using rule 46 (expression -> expression DIVIDE expression .)
    LESSEREQ        reduce using rule 46 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 46 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 46 (expression -> expression DIVIDE expression .)
    LOGOR           reduce using rule 46 (expression -> expression DIVIDE expression .)
    LOGAND          reduce using rule 46 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]
  ! ASTERISK        [ shift and go to state 102 ]
  ! DIVIDE          [ shift and go to state 100 ]


state 127

    (45) expression -> expression ASTERISK expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 45 (expression -> expression ASTERISK expression .)
    MINUS           reduce using rule 45 (expression -> expression ASTERISK expression .)
    ASTERISK        reduce using rule 45 (expression -> expression ASTERISK expression .)
    DIVIDE          reduce using rule 45 (expression -> expression ASTERISK expression .)
    EQUALS          reduce using rule 45 (expression -> expression ASTERISK expression .)
    NOTEQUAL        reduce using rule 45 (expression -> expression ASTERISK expression .)
    GREATER         reduce using rule 45 (expression -> expression ASTERISK expression .)
    LESSER          reduce using rule 45 (expression -> expression ASTERISK expression .)
    GREATEREQ       reduce using rule 45 (expression -> expression ASTERISK expression .)
    LESSEREQ        reduce using rule 45 (expression -> expression ASTERISK expression .)
    SEMICOLON       reduce using rule 45 (expression -> expression ASTERISK expression .)
    RPAREN          reduce using rule 45 (expression -> expression ASTERISK expression .)
    LOGOR           reduce using rule 45 (expression -> expression ASTERISK expression .)
    LOGAND          reduce using rule 45 (expression -> expression ASTERISK expression .)

  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]
  ! ASTERISK        [ shift and go to state 102 ]
  ! DIVIDE          [ shift and go to state 100 ]


state 128

    (43) expression -> expression PLUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 43 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 43 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 43 (expression -> expression PLUS expression .)
    NOTEQUAL        reduce using rule 43 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 43 (expression -> expression PLUS expression .)
    LESSER          reduce using rule 43 (expression -> expression PLUS expression .)
    GREATEREQ       reduce using rule 43 (expression -> expression PLUS expression .)
    LESSEREQ        reduce using rule 43 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 43 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 43 (expression -> expression PLUS expression .)
    LOGOR           reduce using rule 43 (expression -> expression PLUS expression .)
    LOGAND          reduce using rule 43 (expression -> expression PLUS expression .)
    ASTERISK        shift and go to state 102
    DIVIDE          shift and go to state 100

  ! ASTERISK        [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]


state 129

    (62) b_expression -> expression sign1 expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression

    LOGOR           reduce using rule 62 (b_expression -> expression sign1 expression .)
    LOGAND          reduce using rule 62 (b_expression -> expression sign1 expression .)
    RPAREN          reduce using rule 62 (b_expression -> expression sign1 expression .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 108
    ASTERISK        shift and go to state 102
    DIVIDE          shift and go to state 100


state 130

    (44) expression -> expression MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . ASTERISK expression
    (46) expression -> expression . DIVIDE expression

    PLUS            reduce using rule 44 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 44 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 44 (expression -> expression MINUS expression .)
    NOTEQUAL        reduce using rule 44 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 44 (expression -> expression MINUS expression .)
    LESSER          reduce using rule 44 (expression -> expression MINUS expression .)
    GREATEREQ       reduce using rule 44 (expression -> expression MINUS expression .)
    LESSEREQ        reduce using rule 44 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 44 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 44 (expression -> expression MINUS expression .)
    LOGOR           reduce using rule 44 (expression -> expression MINUS expression .)
    LOGAND          reduce using rule 44 (expression -> expression MINUS expression .)
    ASTERISK        shift and go to state 102
    DIVIDE          shift and go to state 100

  ! ASTERISK        [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 106 ]
  ! MINUS           [ shift and go to state 108 ]


state 131

    (60) if_stat -> IF LPAREN b_expression RPAREN code_block .
    (61) if_stat -> IF LPAREN b_expression RPAREN code_block . ELSE code_block

    WHILE           reduce using rule 60 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    IF              reduce using rule 60 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    NAME            reduce using rule 60 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    ASTERISK        reduce using rule 60 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    INT             reduce using rule 60 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    FLOAT           reduce using rule 60 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    RBRACE          reduce using rule 60 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    RETURN          reduce using rule 60 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    ELSE            shift and go to state 133

  ! ELSE            [ reduce using rule 60 (if_stat -> IF LPAREN b_expression RPAREN code_block .) ]


state 132

    (58) code_block -> LBRACE function_content . RBRACE

    RBRACE          shift and go to state 134


state 133

    (61) if_stat -> IF LPAREN b_expression RPAREN code_block ELSE . code_block
    (55) code_block -> . if_stat
    (56) code_block -> . while_stat
    (57) code_block -> . assignment_statement
    (58) code_block -> . LBRACE function_content RBRACE
    (60) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (61) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (59) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (36) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (37) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (38) assignment_statement -> . ID EQUAL function_call
    (39) assignment_statement -> . LEFT EQUAL function_call
    (40) ID -> . NAME
    (41) LEFT -> . ASTERISK var

    LBRACE          shift and go to state 117
    IF              shift and go to state 47
    WHILE           shift and go to state 40
    NAME            shift and go to state 120
    ASTERISK        shift and go to state 44

    code_block                     shift and go to state 135
    while_stat                     shift and go to state 122
    if_stat                        shift and go to state 119
    assignment_statement           shift and go to state 118
    LEFT                           shift and go to state 42
    ID                             shift and go to state 46

state 134

    (58) code_block -> LBRACE function_content RBRACE .

    WHILE           reduce using rule 58 (code_block -> LBRACE function_content RBRACE .)
    IF              reduce using rule 58 (code_block -> LBRACE function_content RBRACE .)
    NAME            reduce using rule 58 (code_block -> LBRACE function_content RBRACE .)
    ASTERISK        reduce using rule 58 (code_block -> LBRACE function_content RBRACE .)
    INT             reduce using rule 58 (code_block -> LBRACE function_content RBRACE .)
    FLOAT           reduce using rule 58 (code_block -> LBRACE function_content RBRACE .)
    RBRACE          reduce using rule 58 (code_block -> LBRACE function_content RBRACE .)
    RETURN          reduce using rule 58 (code_block -> LBRACE function_content RBRACE .)
    ELSE            reduce using rule 58 (code_block -> LBRACE function_content RBRACE .)


state 135

    (61) if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .

    WHILE           reduce using rule 61 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    IF              reduce using rule 61 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    NAME            reduce using rule 61 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    ASTERISK        reduce using rule 61 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    INT             reduce using rule 61 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    FLOAT           reduce using rule 61 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    RBRACE          reduce using rule 61 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    RETURN          reduce using rule 61 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    ELSE            reduce using rule 61 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGOR in state 123 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 123 resolved as shift
