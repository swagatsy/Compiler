Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> final_program
Rule 1     final_program -> program_content
Rule 2     program_content -> function_dec program_content
Rule 3     program_content -> function_body program_content
Rule 4     program_content -> program program_content
Rule 5     program_content -> function_dec
Rule 6     program_content -> function_body
Rule 7     program_content -> program
Rule 8     program_content -> declaration
Rule 9     program_content -> declaration program_content
Rule 10    function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON
Rule 11    function_dec -> VOID namevar LPAREN arguments RPAREN SEMICOLON
Rule 12    arguments -> datatype pointer
Rule 13    arguments -> datatype namevar
Rule 14    arguments -> datatype pointer COMMA arguments
Rule 15    arguments -> datatype namevar COMMA arguments
Rule 16    arguments -> epsilon
Rule 17    function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
Rule 18    function_body -> VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE
Rule 19    return_stat -> RETURN LEFT SEMICOLON
Rule 20    return_stat -> RETURN ID SEMICOLON
Rule 21    return_stat2 -> RETURN SEMICOLON
Rule 22    return_stat2 -> epsilon
Rule 23    function_call -> NAME LPAREN arglist RPAREN SEMICOLON
Rule 24    function_call -> NAME LPAREN RPAREN SEMICOLON
Rule 25    arglist -> LEFT
Rule 26    arglist -> ID
Rule 27    arglist -> LEFT COMMA arglist
Rule 28    arglist -> ID COMMA arglist
Rule 29    program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
Rule 30    function_content -> assignment_statement
Rule 31    function_content -> while_stat
Rule 32    function_content -> if_stat
Rule 33    function_content -> function_call
Rule 34    function_content -> assignment_statement function_content
Rule 35    function_content -> while_stat function_content
Rule 36    function_content -> if_stat function_content
Rule 37    function_content -> function_call function_content
Rule 38    function_content -> declaration
Rule 39    function_content -> declaration function_content
Rule 40    function_content -> epsilon
Rule 41    declaration -> datatype varlist SEMICOLON
Rule 42    datatype -> INT
Rule 43    datatype -> FLOAT
Rule 44    namevar -> NAME
Rule 45    varlist -> namevar COMMA varlist
Rule 46    varlist -> pointer COMMA varlist
Rule 47    varlist -> namevar
Rule 48    varlist -> pointer
Rule 49    pointer -> ASTERISK pointer
Rule 50    pointer -> ASTERISK namevar
Rule 51    assignment_statement -> ID EQUAL RIGHT SEMICOLON
Rule 52    assignment_statement -> LEFT EQUAL expression SEMICOLON
Rule 53    assignment_statement -> ID EQUAL function_call
Rule 54    assignment_statement -> LEFT EQUAL function_call
Rule 55    ID -> NAME
Rule 56    LEFT -> ASTERISK var
Rule 57    RIGHT -> AMPERSAND var
Rule 58    expression -> expression PLUS expression
Rule 59    expression -> expression MINUS expression
Rule 60    expression -> expression ASTERISK expression
Rule 61    expression -> expression DIVIDE expression
Rule 62    expression -> var
Rule 63    expression -> NUMBERvar
Rule 64    expression -> LPAREN expression RPAREN
Rule 65    NUMBERvar -> NUMBER
Rule 66    NUMBERvar -> NUMBER2
Rule 67    var -> ASTERISK var
Rule 68    var -> AMPERSAND var
Rule 69    var -> NAME
Rule 70    expression -> MINUS expression
Rule 71    code_block -> if_stat
Rule 72    code_block -> while_stat
Rule 73    code_block -> assignment_statement
Rule 74    code_block -> LBRACE function_content RBRACE
Rule 75    while_stat -> WHILE LPAREN b_expression RPAREN code_block
Rule 76    if_stat -> IF LPAREN b_expression RPAREN code_block
Rule 77    if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block
Rule 78    b_expression -> expression sign1 expression
Rule 79    b_expression -> b_expression sign2 b_expression
Rule 80    b_expression -> LPAREN b_expression RPAREN
Rule 81    sign1 -> EQUALS
Rule 82    sign1 -> NOTEQUAL
Rule 83    sign1 -> GREATER
Rule 84    sign1 -> LESSER
Rule 85    sign1 -> GREATEREQ
Rule 86    sign1 -> LESSEREQ
Rule 87    sign2 -> LOGOR
Rule 88    sign2 -> LOGAND
Rule 89    epsilon -> <empty>

Terminals, with rules where they appear

AMPERSAND            : 57 68
ASTERISK             : 49 50 56 60 67
COMMA                : 14 15 27 28 45 46
DIVIDE               : 61
ELSE                 : 77
EQUAL                : 51 52 53 54
EQUALS               : 81
FLOAT                : 43
GREATER              : 83
GREATEREQ            : 85
IF                   : 76 77
INT                  : 42
LBRACE               : 17 18 29 74
LESSER               : 84
LESSEREQ             : 86
LOGAND               : 88
LOGOR                : 87
LPAREN               : 10 11 17 18 23 24 29 64 75 76 77 80
MAIN                 : 29
MINUS                : 59 70
NAME                 : 23 24 44 55 69
NOTEQUAL             : 82
NUMBER               : 65
NUMBER2              : 66
PLUS                 : 58
RBRACE               : 17 18 29 74
RETURN               : 19 20 21
RPAREN               : 10 11 17 18 23 24 29 64 75 76 77 80
SEMICOLON            : 10 11 19 20 21 23 24 41 51 52
VOID                 : 11 18 29
WHILE                : 75
error                : 

Nonterminals, with rules where they appear

ID                   : 20 26 28 51 53
LEFT                 : 19 25 27 52 54
NUMBERvar            : 63
RIGHT                : 51
arglist              : 23 27 28
arguments            : 10 11 14 15 17 18
assignment_statement : 30 34 73
b_expression         : 75 76 77 79 79 80
code_block           : 75 76 77 77
datatype             : 10 12 13 14 15 17 41
declaration          : 8 9 38 39
epsilon              : 16 22 40
expression           : 52 58 58 59 59 60 60 61 61 64 70 78 78
final_program        : 0
function_body        : 3 6
function_call        : 33 37 53 54
function_content     : 17 18 29 34 35 36 37 39 74
function_dec         : 2 5
if_stat              : 32 36 71
namevar              : 11 13 15 18 45 47 50
pointer              : 10 12 14 17 46 48 49
program              : 4 7
program_content      : 1 2 3 4 9
return_stat          : 17
return_stat2         : 18
sign1                : 78
sign2                : 79
var                  : 56 57 62 67 68
varlist              : 41 45 46
while_stat           : 31 35 72

Parsing method: LALR

state 0

    (0) S' -> . final_program
    (1) final_program -> . program_content
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . VOID namevar LPAREN arguments RPAREN SEMICOLON
    (17) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (18) function_body -> . VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE
    (29) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (41) declaration -> . datatype varlist SEMICOLON
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    final_program                  shift and go to state 4
    program_content                shift and go to state 7
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 1

    (11) function_dec -> VOID . namevar LPAREN arguments RPAREN SEMICOLON
    (18) function_body -> VOID . namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE
    (29) program -> VOID . MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (44) namevar -> . NAME

    MAIN            shift and go to state 13
    NAME            shift and go to state 11

    namevar                        shift and go to state 12

state 2

    (3) program_content -> function_body . program_content
    (6) program_content -> function_body .
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . VOID namevar LPAREN arguments RPAREN SEMICOLON
    (17) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (18) function_body -> . VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE
    (29) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (41) declaration -> . datatype varlist SEMICOLON
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

    $end            reduce using rule 6 (program_content -> function_body .)
    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    program_content                shift and go to state 14
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 3

    (4) program_content -> program . program_content
    (7) program_content -> program .
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . VOID namevar LPAREN arguments RPAREN SEMICOLON
    (17) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (18) function_body -> . VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE
    (29) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (41) declaration -> . datatype varlist SEMICOLON
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

    $end            reduce using rule 7 (program_content -> program .)
    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    program_content                shift and go to state 15
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 4

    (0) S' -> final_program .



state 5

    (2) program_content -> function_dec . program_content
    (5) program_content -> function_dec .
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . VOID namevar LPAREN arguments RPAREN SEMICOLON
    (17) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (18) function_body -> . VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE
    (29) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (41) declaration -> . datatype varlist SEMICOLON
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

    $end            reduce using rule 5 (program_content -> function_dec .)
    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    program_content                shift and go to state 16
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 6

    (8) program_content -> declaration .
    (9) program_content -> declaration . program_content
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . VOID namevar LPAREN arguments RPAREN SEMICOLON
    (17) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (18) function_body -> . VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE
    (29) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (41) declaration -> . datatype varlist SEMICOLON
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

    $end            reduce using rule 8 (program_content -> declaration .)
    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    program_content                shift and go to state 17
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 7

    (1) final_program -> program_content .

    $end            reduce using rule 1 (final_program -> program_content .)


state 8

    (10) function_dec -> datatype . pointer LPAREN arguments RPAREN SEMICOLON
    (17) function_body -> datatype . pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (41) declaration -> datatype . varlist SEMICOLON
    (49) pointer -> . ASTERISK pointer
    (50) pointer -> . ASTERISK namevar
    (45) varlist -> . namevar COMMA varlist
    (46) varlist -> . pointer COMMA varlist
    (47) varlist -> . namevar
    (48) varlist -> . pointer
    (44) namevar -> . NAME

    ASTERISK        shift and go to state 18
    NAME            shift and go to state 11

    namevar                        shift and go to state 19
    varlist                        shift and go to state 20
    pointer                        shift and go to state 21

state 9

    (43) datatype -> FLOAT .

    NAME            reduce using rule 43 (datatype -> FLOAT .)
    ASTERISK        reduce using rule 43 (datatype -> FLOAT .)


state 10

    (42) datatype -> INT .

    NAME            reduce using rule 42 (datatype -> INT .)
    ASTERISK        reduce using rule 42 (datatype -> INT .)


state 11

    (44) namevar -> NAME .

    COMMA           reduce using rule 44 (namevar -> NAME .)
    SEMICOLON       reduce using rule 44 (namevar -> NAME .)
    LPAREN          reduce using rule 44 (namevar -> NAME .)
    RPAREN          reduce using rule 44 (namevar -> NAME .)


state 12

    (11) function_dec -> VOID namevar . LPAREN arguments RPAREN SEMICOLON
    (18) function_body -> VOID namevar . LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE

    LPAREN          shift and go to state 22


state 13

    (29) program -> VOID MAIN . LPAREN RPAREN LBRACE function_content RBRACE

    LPAREN          shift and go to state 23


state 14

    (3) program_content -> function_body program_content .

    $end            reduce using rule 3 (program_content -> function_body program_content .)


state 15

    (4) program_content -> program program_content .

    $end            reduce using rule 4 (program_content -> program program_content .)


state 16

    (2) program_content -> function_dec program_content .

    $end            reduce using rule 2 (program_content -> function_dec program_content .)


state 17

    (9) program_content -> declaration program_content .

    $end            reduce using rule 9 (program_content -> declaration program_content .)


state 18

    (49) pointer -> ASTERISK . pointer
    (50) pointer -> ASTERISK . namevar
    (49) pointer -> . ASTERISK pointer
    (50) pointer -> . ASTERISK namevar
    (44) namevar -> . NAME

    ASTERISK        shift and go to state 18
    NAME            shift and go to state 11

    pointer                        shift and go to state 24
    namevar                        shift and go to state 25

state 19

    (45) varlist -> namevar . COMMA varlist
    (47) varlist -> namevar .

    COMMA           shift and go to state 26
    SEMICOLON       reduce using rule 47 (varlist -> namevar .)


state 20

    (41) declaration -> datatype varlist . SEMICOLON

    SEMICOLON       shift and go to state 27


state 21

    (10) function_dec -> datatype pointer . LPAREN arguments RPAREN SEMICOLON
    (17) function_body -> datatype pointer . LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (46) varlist -> pointer . COMMA varlist
    (48) varlist -> pointer .

    LPAREN          shift and go to state 29
    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 48 (varlist -> pointer .)


state 22

    (11) function_dec -> VOID namevar LPAREN . arguments RPAREN SEMICOLON
    (18) function_body -> VOID namevar LPAREN . arguments RPAREN LBRACE function_content return_stat2 RBRACE
    (12) arguments -> . datatype pointer
    (13) arguments -> . datatype namevar
    (14) arguments -> . datatype pointer COMMA arguments
    (15) arguments -> . datatype namevar COMMA arguments
    (16) arguments -> . epsilon
    (42) datatype -> . INT
    (43) datatype -> . FLOAT
    (89) epsilon -> .

    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    RPAREN          reduce using rule 89 (epsilon -> .)

    datatype                       shift and go to state 30
    epsilon                        shift and go to state 31
    arguments                      shift and go to state 32

state 23

    (29) program -> VOID MAIN LPAREN . RPAREN LBRACE function_content RBRACE

    RPAREN          shift and go to state 33


state 24

    (49) pointer -> ASTERISK pointer .

    COMMA           reduce using rule 49 (pointer -> ASTERISK pointer .)
    SEMICOLON       reduce using rule 49 (pointer -> ASTERISK pointer .)
    LPAREN          reduce using rule 49 (pointer -> ASTERISK pointer .)
    RPAREN          reduce using rule 49 (pointer -> ASTERISK pointer .)


state 25

    (50) pointer -> ASTERISK namevar .

    COMMA           reduce using rule 50 (pointer -> ASTERISK namevar .)
    SEMICOLON       reduce using rule 50 (pointer -> ASTERISK namevar .)
    LPAREN          reduce using rule 50 (pointer -> ASTERISK namevar .)
    RPAREN          reduce using rule 50 (pointer -> ASTERISK namevar .)


state 26

    (45) varlist -> namevar COMMA . varlist
    (45) varlist -> . namevar COMMA varlist
    (46) varlist -> . pointer COMMA varlist
    (47) varlist -> . namevar
    (48) varlist -> . pointer
    (44) namevar -> . NAME
    (49) pointer -> . ASTERISK pointer
    (50) pointer -> . ASTERISK namevar

    NAME            shift and go to state 11
    ASTERISK        shift and go to state 18

    varlist                        shift and go to state 34
    pointer                        shift and go to state 35
    namevar                        shift and go to state 19

state 27

    (41) declaration -> datatype varlist SEMICOLON .

    VOID            reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)
    INT             reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)
    FLOAT           reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)
    $end            reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)
    WHILE           reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)
    IF              reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)
    NAME            reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)
    ASTERISK        reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)
    RBRACE          reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)
    RETURN          reduce using rule 41 (declaration -> datatype varlist SEMICOLON .)


state 28

    (46) varlist -> pointer COMMA . varlist
    (45) varlist -> . namevar COMMA varlist
    (46) varlist -> . pointer COMMA varlist
    (47) varlist -> . namevar
    (48) varlist -> . pointer
    (44) namevar -> . NAME
    (49) pointer -> . ASTERISK pointer
    (50) pointer -> . ASTERISK namevar

    NAME            shift and go to state 11
    ASTERISK        shift and go to state 18

    varlist                        shift and go to state 36
    pointer                        shift and go to state 35
    namevar                        shift and go to state 19

state 29

    (10) function_dec -> datatype pointer LPAREN . arguments RPAREN SEMICOLON
    (17) function_body -> datatype pointer LPAREN . arguments RPAREN LBRACE function_content return_stat RBRACE
    (12) arguments -> . datatype pointer
    (13) arguments -> . datatype namevar
    (14) arguments -> . datatype pointer COMMA arguments
    (15) arguments -> . datatype namevar COMMA arguments
    (16) arguments -> . epsilon
    (42) datatype -> . INT
    (43) datatype -> . FLOAT
    (89) epsilon -> .

    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    RPAREN          reduce using rule 89 (epsilon -> .)

    datatype                       shift and go to state 30
    epsilon                        shift and go to state 31
    arguments                      shift and go to state 37

state 30

    (12) arguments -> datatype . pointer
    (13) arguments -> datatype . namevar
    (14) arguments -> datatype . pointer COMMA arguments
    (15) arguments -> datatype . namevar COMMA arguments
    (49) pointer -> . ASTERISK pointer
    (50) pointer -> . ASTERISK namevar
    (44) namevar -> . NAME

    ASTERISK        shift and go to state 18
    NAME            shift and go to state 11

    pointer                        shift and go to state 39
    namevar                        shift and go to state 38

state 31

    (16) arguments -> epsilon .

    RPAREN          reduce using rule 16 (arguments -> epsilon .)


state 32

    (11) function_dec -> VOID namevar LPAREN arguments . RPAREN SEMICOLON
    (18) function_body -> VOID namevar LPAREN arguments . RPAREN LBRACE function_content return_stat2 RBRACE

    RPAREN          shift and go to state 40


state 33

    (29) program -> VOID MAIN LPAREN RPAREN . LBRACE function_content RBRACE

    LBRACE          shift and go to state 41


state 34

    (45) varlist -> namevar COMMA varlist .

    SEMICOLON       reduce using rule 45 (varlist -> namevar COMMA varlist .)


state 35

    (46) varlist -> pointer . COMMA varlist
    (48) varlist -> pointer .

    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 48 (varlist -> pointer .)


state 36

    (46) varlist -> pointer COMMA varlist .

    SEMICOLON       reduce using rule 46 (varlist -> pointer COMMA varlist .)


state 37

    (10) function_dec -> datatype pointer LPAREN arguments . RPAREN SEMICOLON
    (17) function_body -> datatype pointer LPAREN arguments . RPAREN LBRACE function_content return_stat RBRACE

    RPAREN          shift and go to state 42


state 38

    (13) arguments -> datatype namevar .
    (15) arguments -> datatype namevar . COMMA arguments

    RPAREN          reduce using rule 13 (arguments -> datatype namevar .)
    COMMA           shift and go to state 43


state 39

    (12) arguments -> datatype pointer .
    (14) arguments -> datatype pointer . COMMA arguments

    RPAREN          reduce using rule 12 (arguments -> datatype pointer .)
    COMMA           shift and go to state 44


state 40

    (11) function_dec -> VOID namevar LPAREN arguments RPAREN . SEMICOLON
    (18) function_body -> VOID namevar LPAREN arguments RPAREN . LBRACE function_content return_stat2 RBRACE

    SEMICOLON       shift and go to state 46
    LBRACE          shift and go to state 45


state 41

    (29) program -> VOID MAIN LPAREN RPAREN LBRACE . function_content RBRACE
    (30) function_content -> . assignment_statement
    (31) function_content -> . while_stat
    (32) function_content -> . if_stat
    (33) function_content -> . function_call
    (34) function_content -> . assignment_statement function_content
    (35) function_content -> . while_stat function_content
    (36) function_content -> . if_stat function_content
    (37) function_content -> . function_call function_content
    (38) function_content -> . declaration
    (39) function_content -> . declaration function_content
    (40) function_content -> . epsilon
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (41) declaration -> . datatype varlist SEMICOLON
    (89) epsilon -> .
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

    WHILE           shift and go to state 49
    IF              shift and go to state 57
    NAME            shift and go to state 47
    RBRACE          reduce using rule 89 (epsilon -> .)
    ASTERISK        shift and go to state 54
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    epsilon                        shift and go to state 53
    function_content               shift and go to state 58
    while_stat                     shift and go to state 59
    datatype                       shift and go to state 60
    if_stat                        shift and go to state 51
    assignment_statement           shift and go to state 50
    function_call                  shift and go to state 48
    declaration                    shift and go to state 55
    ID                             shift and go to state 56
    LEFT                           shift and go to state 52

state 42

    (10) function_dec -> datatype pointer LPAREN arguments RPAREN . SEMICOLON
    (17) function_body -> datatype pointer LPAREN arguments RPAREN . LBRACE function_content return_stat RBRACE

    SEMICOLON       shift and go to state 62
    LBRACE          shift and go to state 61


state 43

    (15) arguments -> datatype namevar COMMA . arguments
    (12) arguments -> . datatype pointer
    (13) arguments -> . datatype namevar
    (14) arguments -> . datatype pointer COMMA arguments
    (15) arguments -> . datatype namevar COMMA arguments
    (16) arguments -> . epsilon
    (42) datatype -> . INT
    (43) datatype -> . FLOAT
    (89) epsilon -> .

    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    RPAREN          reduce using rule 89 (epsilon -> .)

    datatype                       shift and go to state 30
    epsilon                        shift and go to state 31
    arguments                      shift and go to state 63

state 44

    (14) arguments -> datatype pointer COMMA . arguments
    (12) arguments -> . datatype pointer
    (13) arguments -> . datatype namevar
    (14) arguments -> . datatype pointer COMMA arguments
    (15) arguments -> . datatype namevar COMMA arguments
    (16) arguments -> . epsilon
    (42) datatype -> . INT
    (43) datatype -> . FLOAT
    (89) epsilon -> .

    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    RPAREN          reduce using rule 89 (epsilon -> .)

    datatype                       shift and go to state 30
    epsilon                        shift and go to state 31
    arguments                      shift and go to state 64

state 45

    (18) function_body -> VOID namevar LPAREN arguments RPAREN LBRACE . function_content return_stat2 RBRACE
    (30) function_content -> . assignment_statement
    (31) function_content -> . while_stat
    (32) function_content -> . if_stat
    (33) function_content -> . function_call
    (34) function_content -> . assignment_statement function_content
    (35) function_content -> . while_stat function_content
    (36) function_content -> . if_stat function_content
    (37) function_content -> . function_call function_content
    (38) function_content -> . declaration
    (39) function_content -> . declaration function_content
    (40) function_content -> . epsilon
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (41) declaration -> . datatype varlist SEMICOLON
    (89) epsilon -> .
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

    WHILE           shift and go to state 49
    IF              shift and go to state 57
    NAME            shift and go to state 47
    RETURN          reduce using rule 89 (epsilon -> .)
    RBRACE          reduce using rule 89 (epsilon -> .)
    ASTERISK        shift and go to state 54
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    epsilon                        shift and go to state 53
    function_content               shift and go to state 65
    while_stat                     shift and go to state 59
    datatype                       shift and go to state 60
    if_stat                        shift and go to state 51
    assignment_statement           shift and go to state 50
    function_call                  shift and go to state 48
    declaration                    shift and go to state 55
    LEFT                           shift and go to state 52
    ID                             shift and go to state 56

state 46

    (11) function_dec -> VOID namevar LPAREN arguments RPAREN SEMICOLON .

    VOID            reduce using rule 11 (function_dec -> VOID namevar LPAREN arguments RPAREN SEMICOLON .)
    INT             reduce using rule 11 (function_dec -> VOID namevar LPAREN arguments RPAREN SEMICOLON .)
    FLOAT           reduce using rule 11 (function_dec -> VOID namevar LPAREN arguments RPAREN SEMICOLON .)
    $end            reduce using rule 11 (function_dec -> VOID namevar LPAREN arguments RPAREN SEMICOLON .)


state 47

    (23) function_call -> NAME . LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> NAME . LPAREN RPAREN SEMICOLON
    (55) ID -> NAME .

    LPAREN          shift and go to state 66
    EQUAL           reduce using rule 55 (ID -> NAME .)


state 48

    (33) function_content -> function_call .
    (37) function_content -> function_call . function_content
    (30) function_content -> . assignment_statement
    (31) function_content -> . while_stat
    (32) function_content -> . if_stat
    (33) function_content -> . function_call
    (34) function_content -> . assignment_statement function_content
    (35) function_content -> . while_stat function_content
    (36) function_content -> . if_stat function_content
    (37) function_content -> . function_call function_content
    (38) function_content -> . declaration
    (39) function_content -> . declaration function_content
    (40) function_content -> . epsilon
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (41) declaration -> . datatype varlist SEMICOLON
    (89) epsilon -> .
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

  ! reduce/reduce conflict for RBRACE resolved using rule 33 (function_content -> function_call .)
  ! reduce/reduce conflict for RETURN resolved using rule 33 (function_content -> function_call .)
    RBRACE          reduce using rule 33 (function_content -> function_call .)
    RETURN          reduce using rule 33 (function_content -> function_call .)
    WHILE           shift and go to state 49
    IF              shift and go to state 57
    NAME            shift and go to state 47
    ASTERISK        shift and go to state 54
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

  ! RBRACE          [ reduce using rule 89 (epsilon -> .) ]
  ! RETURN          [ reduce using rule 89 (epsilon -> .) ]

    epsilon                        shift and go to state 53
    function_content               shift and go to state 67
    while_stat                     shift and go to state 59
    datatype                       shift and go to state 60
    if_stat                        shift and go to state 51
    assignment_statement           shift and go to state 50
    function_call                  shift and go to state 48
    declaration                    shift and go to state 55
    ID                             shift and go to state 56
    LEFT                           shift and go to state 52

state 49

    (75) while_stat -> WHILE . LPAREN b_expression RPAREN code_block

    LPAREN          shift and go to state 68


state 50

    (30) function_content -> assignment_statement .
    (34) function_content -> assignment_statement . function_content
    (30) function_content -> . assignment_statement
    (31) function_content -> . while_stat
    (32) function_content -> . if_stat
    (33) function_content -> . function_call
    (34) function_content -> . assignment_statement function_content
    (35) function_content -> . while_stat function_content
    (36) function_content -> . if_stat function_content
    (37) function_content -> . function_call function_content
    (38) function_content -> . declaration
    (39) function_content -> . declaration function_content
    (40) function_content -> . epsilon
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (41) declaration -> . datatype varlist SEMICOLON
    (89) epsilon -> .
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

  ! reduce/reduce conflict for RBRACE resolved using rule 30 (function_content -> assignment_statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 30 (function_content -> assignment_statement .)
    RBRACE          reduce using rule 30 (function_content -> assignment_statement .)
    RETURN          reduce using rule 30 (function_content -> assignment_statement .)
    WHILE           shift and go to state 49
    IF              shift and go to state 57
    NAME            shift and go to state 47
    ASTERISK        shift and go to state 54
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

  ! RBRACE          [ reduce using rule 89 (epsilon -> .) ]
  ! RETURN          [ reduce using rule 89 (epsilon -> .) ]

    epsilon                        shift and go to state 53
    function_content               shift and go to state 69
    while_stat                     shift and go to state 59
    datatype                       shift and go to state 60
    if_stat                        shift and go to state 51
    assignment_statement           shift and go to state 50
    function_call                  shift and go to state 48
    declaration                    shift and go to state 55
    ID                             shift and go to state 56
    LEFT                           shift and go to state 52

state 51

    (32) function_content -> if_stat .
    (36) function_content -> if_stat . function_content
    (30) function_content -> . assignment_statement
    (31) function_content -> . while_stat
    (32) function_content -> . if_stat
    (33) function_content -> . function_call
    (34) function_content -> . assignment_statement function_content
    (35) function_content -> . while_stat function_content
    (36) function_content -> . if_stat function_content
    (37) function_content -> . function_call function_content
    (38) function_content -> . declaration
    (39) function_content -> . declaration function_content
    (40) function_content -> . epsilon
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (41) declaration -> . datatype varlist SEMICOLON
    (89) epsilon -> .
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

  ! reduce/reduce conflict for RBRACE resolved using rule 32 (function_content -> if_stat .)
  ! reduce/reduce conflict for RETURN resolved using rule 32 (function_content -> if_stat .)
    RBRACE          reduce using rule 32 (function_content -> if_stat .)
    RETURN          reduce using rule 32 (function_content -> if_stat .)
    WHILE           shift and go to state 49
    IF              shift and go to state 57
    NAME            shift and go to state 47
    ASTERISK        shift and go to state 54
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

  ! RBRACE          [ reduce using rule 89 (epsilon -> .) ]
  ! RETURN          [ reduce using rule 89 (epsilon -> .) ]

    epsilon                        shift and go to state 53
    function_content               shift and go to state 70
    while_stat                     shift and go to state 59
    datatype                       shift and go to state 60
    if_stat                        shift and go to state 51
    assignment_statement           shift and go to state 50
    function_call                  shift and go to state 48
    declaration                    shift and go to state 55
    ID                             shift and go to state 56
    LEFT                           shift and go to state 52

state 52

    (52) assignment_statement -> LEFT . EQUAL expression SEMICOLON
    (54) assignment_statement -> LEFT . EQUAL function_call

    EQUAL           shift and go to state 71


state 53

    (40) function_content -> epsilon .

    RBRACE          reduce using rule 40 (function_content -> epsilon .)
    RETURN          reduce using rule 40 (function_content -> epsilon .)


state 54

    (56) LEFT -> ASTERISK . var
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME

    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75

    var                            shift and go to state 72

state 55

    (38) function_content -> declaration .
    (39) function_content -> declaration . function_content
    (30) function_content -> . assignment_statement
    (31) function_content -> . while_stat
    (32) function_content -> . if_stat
    (33) function_content -> . function_call
    (34) function_content -> . assignment_statement function_content
    (35) function_content -> . while_stat function_content
    (36) function_content -> . if_stat function_content
    (37) function_content -> . function_call function_content
    (38) function_content -> . declaration
    (39) function_content -> . declaration function_content
    (40) function_content -> . epsilon
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (41) declaration -> . datatype varlist SEMICOLON
    (89) epsilon -> .
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

  ! reduce/reduce conflict for RBRACE resolved using rule 38 (function_content -> declaration .)
  ! reduce/reduce conflict for RETURN resolved using rule 38 (function_content -> declaration .)
    RBRACE          reduce using rule 38 (function_content -> declaration .)
    RETURN          reduce using rule 38 (function_content -> declaration .)
    WHILE           shift and go to state 49
    IF              shift and go to state 57
    NAME            shift and go to state 47
    ASTERISK        shift and go to state 54
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

  ! RBRACE          [ reduce using rule 89 (epsilon -> .) ]
  ! RETURN          [ reduce using rule 89 (epsilon -> .) ]

    epsilon                        shift and go to state 53
    function_content               shift and go to state 76
    while_stat                     shift and go to state 59
    datatype                       shift and go to state 60
    if_stat                        shift and go to state 51
    assignment_statement           shift and go to state 50
    function_call                  shift and go to state 48
    declaration                    shift and go to state 55
    ID                             shift and go to state 56
    LEFT                           shift and go to state 52

state 56

    (51) assignment_statement -> ID . EQUAL RIGHT SEMICOLON
    (53) assignment_statement -> ID . EQUAL function_call

    EQUAL           shift and go to state 77


state 57

    (76) if_stat -> IF . LPAREN b_expression RPAREN code_block
    (77) if_stat -> IF . LPAREN b_expression RPAREN code_block ELSE code_block

    LPAREN          shift and go to state 78


state 58

    (29) program -> VOID MAIN LPAREN RPAREN LBRACE function_content . RBRACE

    RBRACE          shift and go to state 79


state 59

    (31) function_content -> while_stat .
    (35) function_content -> while_stat . function_content
    (30) function_content -> . assignment_statement
    (31) function_content -> . while_stat
    (32) function_content -> . if_stat
    (33) function_content -> . function_call
    (34) function_content -> . assignment_statement function_content
    (35) function_content -> . while_stat function_content
    (36) function_content -> . if_stat function_content
    (37) function_content -> . function_call function_content
    (38) function_content -> . declaration
    (39) function_content -> . declaration function_content
    (40) function_content -> . epsilon
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (41) declaration -> . datatype varlist SEMICOLON
    (89) epsilon -> .
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

  ! reduce/reduce conflict for RBRACE resolved using rule 31 (function_content -> while_stat .)
  ! reduce/reduce conflict for RETURN resolved using rule 31 (function_content -> while_stat .)
    RBRACE          reduce using rule 31 (function_content -> while_stat .)
    RETURN          reduce using rule 31 (function_content -> while_stat .)
    WHILE           shift and go to state 49
    IF              shift and go to state 57
    NAME            shift and go to state 47
    ASTERISK        shift and go to state 54
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

  ! RBRACE          [ reduce using rule 89 (epsilon -> .) ]
  ! RETURN          [ reduce using rule 89 (epsilon -> .) ]

    epsilon                        shift and go to state 53
    while_stat                     shift and go to state 59
    function_content               shift and go to state 80
    datatype                       shift and go to state 60
    if_stat                        shift and go to state 51
    assignment_statement           shift and go to state 50
    function_call                  shift and go to state 48
    declaration                    shift and go to state 55
    ID                             shift and go to state 56
    LEFT                           shift and go to state 52

state 60

    (41) declaration -> datatype . varlist SEMICOLON
    (45) varlist -> . namevar COMMA varlist
    (46) varlist -> . pointer COMMA varlist
    (47) varlist -> . namevar
    (48) varlist -> . pointer
    (44) namevar -> . NAME
    (49) pointer -> . ASTERISK pointer
    (50) pointer -> . ASTERISK namevar

    NAME            shift and go to state 11
    ASTERISK        shift and go to state 18

    varlist                        shift and go to state 20
    pointer                        shift and go to state 35
    namevar                        shift and go to state 19

state 61

    (17) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE . function_content return_stat RBRACE
    (30) function_content -> . assignment_statement
    (31) function_content -> . while_stat
    (32) function_content -> . if_stat
    (33) function_content -> . function_call
    (34) function_content -> . assignment_statement function_content
    (35) function_content -> . while_stat function_content
    (36) function_content -> . if_stat function_content
    (37) function_content -> . function_call function_content
    (38) function_content -> . declaration
    (39) function_content -> . declaration function_content
    (40) function_content -> . epsilon
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (41) declaration -> . datatype varlist SEMICOLON
    (89) epsilon -> .
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

    WHILE           shift and go to state 49
    IF              shift and go to state 57
    NAME            shift and go to state 47
    RETURN          reduce using rule 89 (epsilon -> .)
    ASTERISK        shift and go to state 54
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    while_stat                     shift and go to state 59
    function_content               shift and go to state 81
    datatype                       shift and go to state 60
    if_stat                        shift and go to state 51
    epsilon                        shift and go to state 53
    assignment_statement           shift and go to state 50
    function_call                  shift and go to state 48
    declaration                    shift and go to state 55
    ID                             shift and go to state 56
    LEFT                           shift and go to state 52

state 62

    (10) function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .

    VOID            reduce using rule 10 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)
    INT             reduce using rule 10 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)
    FLOAT           reduce using rule 10 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)
    $end            reduce using rule 10 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)


state 63

    (15) arguments -> datatype namevar COMMA arguments .

    RPAREN          reduce using rule 15 (arguments -> datatype namevar COMMA arguments .)


state 64

    (14) arguments -> datatype pointer COMMA arguments .

    RPAREN          reduce using rule 14 (arguments -> datatype pointer COMMA arguments .)


state 65

    (18) function_body -> VOID namevar LPAREN arguments RPAREN LBRACE function_content . return_stat2 RBRACE
    (21) return_stat2 -> . RETURN SEMICOLON
    (22) return_stat2 -> . epsilon
    (89) epsilon -> .

    RETURN          shift and go to state 83
    RBRACE          reduce using rule 89 (epsilon -> .)

    epsilon                        shift and go to state 82
    return_stat2                   shift and go to state 84

state 66

    (23) function_call -> NAME LPAREN . arglist RPAREN SEMICOLON
    (24) function_call -> NAME LPAREN . RPAREN SEMICOLON
    (25) arglist -> . LEFT
    (26) arglist -> . ID
    (27) arglist -> . LEFT COMMA arglist
    (28) arglist -> . ID COMMA arglist
    (56) LEFT -> . ASTERISK var
    (55) ID -> . NAME

    RPAREN          shift and go to state 85
    ASTERISK        shift and go to state 54
    NAME            shift and go to state 86

    arglist                        shift and go to state 87
    ID                             shift and go to state 88
    LEFT                           shift and go to state 89

state 67

    (37) function_content -> function_call function_content .

    RBRACE          reduce using rule 37 (function_content -> function_call function_content .)
    RETURN          reduce using rule 37 (function_content -> function_call function_content .)


state 68

    (75) while_stat -> WHILE LPAREN . b_expression RPAREN code_block
    (78) b_expression -> . expression sign1 expression
    (79) b_expression -> . b_expression sign2 b_expression
    (80) b_expression -> . LPAREN b_expression RPAREN
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 92
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    b_expression                   shift and go to state 91
    NUMBERvar                      shift and go to state 93
    var                            shift and go to state 94
    expression                     shift and go to state 96

state 69

    (34) function_content -> assignment_statement function_content .

    RBRACE          reduce using rule 34 (function_content -> assignment_statement function_content .)
    RETURN          reduce using rule 34 (function_content -> assignment_statement function_content .)


state 70

    (36) function_content -> if_stat function_content .

    RBRACE          reduce using rule 36 (function_content -> if_stat function_content .)
    RETURN          reduce using rule 36 (function_content -> if_stat function_content .)


state 71

    (52) assignment_statement -> LEFT EQUAL . expression SEMICOLON
    (54) assignment_statement -> LEFT EQUAL . function_call
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 100
    MINUS           shift and go to state 97
    NAME            shift and go to state 98
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    function_call                  shift and go to state 99
    NUMBERvar                      shift and go to state 93
    var                            shift and go to state 94
    expression                     shift and go to state 101

state 72

    (56) LEFT -> ASTERISK var .

    EQUAL           reduce using rule 56 (LEFT -> ASTERISK var .)
    COMMA           reduce using rule 56 (LEFT -> ASTERISK var .)
    RPAREN          reduce using rule 56 (LEFT -> ASTERISK var .)
    SEMICOLON       reduce using rule 56 (LEFT -> ASTERISK var .)


state 73

    (68) var -> AMPERSAND . var
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME

    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75

    var                            shift and go to state 102

state 74

    (67) var -> ASTERISK . var
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME

    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75

    var                            shift and go to state 103

state 75

    (69) var -> NAME .

    EQUAL           reduce using rule 69 (var -> NAME .)
    COMMA           reduce using rule 69 (var -> NAME .)
    RPAREN          reduce using rule 69 (var -> NAME .)
    SEMICOLON       reduce using rule 69 (var -> NAME .)
    PLUS            reduce using rule 69 (var -> NAME .)
    MINUS           reduce using rule 69 (var -> NAME .)
    ASTERISK        reduce using rule 69 (var -> NAME .)
    DIVIDE          reduce using rule 69 (var -> NAME .)
    EQUALS          reduce using rule 69 (var -> NAME .)
    NOTEQUAL        reduce using rule 69 (var -> NAME .)
    GREATER         reduce using rule 69 (var -> NAME .)
    LESSER          reduce using rule 69 (var -> NAME .)
    GREATEREQ       reduce using rule 69 (var -> NAME .)
    LESSEREQ        reduce using rule 69 (var -> NAME .)
    LOGOR           reduce using rule 69 (var -> NAME .)
    LOGAND          reduce using rule 69 (var -> NAME .)


state 76

    (39) function_content -> declaration function_content .

    RBRACE          reduce using rule 39 (function_content -> declaration function_content .)
    RETURN          reduce using rule 39 (function_content -> declaration function_content .)


state 77

    (51) assignment_statement -> ID EQUAL . RIGHT SEMICOLON
    (53) assignment_statement -> ID EQUAL . function_call
    (57) RIGHT -> . AMPERSAND var
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON

    AMPERSAND       shift and go to state 107
    NAME            shift and go to state 105

    RIGHT                          shift and go to state 104
    function_call                  shift and go to state 106

state 78

    (76) if_stat -> IF LPAREN . b_expression RPAREN code_block
    (77) if_stat -> IF LPAREN . b_expression RPAREN code_block ELSE code_block
    (78) b_expression -> . expression sign1 expression
    (79) b_expression -> . b_expression sign2 b_expression
    (80) b_expression -> . LPAREN b_expression RPAREN
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 92
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    b_expression                   shift and go to state 108
    NUMBERvar                      shift and go to state 93
    var                            shift and go to state 94
    expression                     shift and go to state 96

state 79

    (29) program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .

    VOID            reduce using rule 29 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)
    INT             reduce using rule 29 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)
    FLOAT           reduce using rule 29 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)
    $end            reduce using rule 29 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)


state 80

    (35) function_content -> while_stat function_content .

    RBRACE          reduce using rule 35 (function_content -> while_stat function_content .)
    RETURN          reduce using rule 35 (function_content -> while_stat function_content .)


state 81

    (17) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content . return_stat RBRACE
    (19) return_stat -> . RETURN LEFT SEMICOLON
    (20) return_stat -> . RETURN ID SEMICOLON

    RETURN          shift and go to state 110

    return_stat                    shift and go to state 109

state 82

    (22) return_stat2 -> epsilon .

    RBRACE          reduce using rule 22 (return_stat2 -> epsilon .)


state 83

    (21) return_stat2 -> RETURN . SEMICOLON

    SEMICOLON       shift and go to state 111


state 84

    (18) function_body -> VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 . RBRACE

    RBRACE          shift and go to state 112


state 85

    (24) function_call -> NAME LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 113


state 86

    (55) ID -> NAME .

    COMMA           reduce using rule 55 (ID -> NAME .)
    RPAREN          reduce using rule 55 (ID -> NAME .)
    EQUAL           reduce using rule 55 (ID -> NAME .)
    SEMICOLON       reduce using rule 55 (ID -> NAME .)


state 87

    (23) function_call -> NAME LPAREN arglist . RPAREN SEMICOLON

    RPAREN          shift and go to state 114


state 88

    (26) arglist -> ID .
    (28) arglist -> ID . COMMA arglist

    RPAREN          reduce using rule 26 (arglist -> ID .)
    COMMA           shift and go to state 115


state 89

    (25) arglist -> LEFT .
    (27) arglist -> LEFT . COMMA arglist

    RPAREN          reduce using rule 25 (arglist -> LEFT .)
    COMMA           shift and go to state 116


state 90

    (65) NUMBERvar -> NUMBER .

    PLUS            reduce using rule 65 (NUMBERvar -> NUMBER .)
    MINUS           reduce using rule 65 (NUMBERvar -> NUMBER .)
    ASTERISK        reduce using rule 65 (NUMBERvar -> NUMBER .)
    DIVIDE          reduce using rule 65 (NUMBERvar -> NUMBER .)
    RPAREN          reduce using rule 65 (NUMBERvar -> NUMBER .)
    LOGOR           reduce using rule 65 (NUMBERvar -> NUMBER .)
    LOGAND          reduce using rule 65 (NUMBERvar -> NUMBER .)
    EQUALS          reduce using rule 65 (NUMBERvar -> NUMBER .)
    NOTEQUAL        reduce using rule 65 (NUMBERvar -> NUMBER .)
    GREATER         reduce using rule 65 (NUMBERvar -> NUMBER .)
    LESSER          reduce using rule 65 (NUMBERvar -> NUMBER .)
    GREATEREQ       reduce using rule 65 (NUMBERvar -> NUMBER .)
    LESSEREQ        reduce using rule 65 (NUMBERvar -> NUMBER .)
    SEMICOLON       reduce using rule 65 (NUMBERvar -> NUMBER .)


state 91

    (75) while_stat -> WHILE LPAREN b_expression . RPAREN code_block
    (79) b_expression -> b_expression . sign2 b_expression
    (87) sign2 -> . LOGOR
    (88) sign2 -> . LOGAND

    RPAREN          shift and go to state 118
    LOGOR           shift and go to state 117
    LOGAND          shift and go to state 119

    sign2                          shift and go to state 120

state 92

    (80) b_expression -> LPAREN . b_expression RPAREN
    (64) expression -> LPAREN . expression RPAREN
    (78) b_expression -> . expression sign1 expression
    (79) b_expression -> . b_expression sign2 b_expression
    (80) b_expression -> . LPAREN b_expression RPAREN
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 92
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    b_expression                   shift and go to state 121
    NUMBERvar                      shift and go to state 93
    var                            shift and go to state 94
    expression                     shift and go to state 122

state 93

    (63) expression -> NUMBERvar .

    RPAREN          reduce using rule 63 (expression -> NUMBERvar .)
    PLUS            reduce using rule 63 (expression -> NUMBERvar .)
    MINUS           reduce using rule 63 (expression -> NUMBERvar .)
    ASTERISK        reduce using rule 63 (expression -> NUMBERvar .)
    DIVIDE          reduce using rule 63 (expression -> NUMBERvar .)
    EQUALS          reduce using rule 63 (expression -> NUMBERvar .)
    NOTEQUAL        reduce using rule 63 (expression -> NUMBERvar .)
    GREATER         reduce using rule 63 (expression -> NUMBERvar .)
    LESSER          reduce using rule 63 (expression -> NUMBERvar .)
    GREATEREQ       reduce using rule 63 (expression -> NUMBERvar .)
    LESSEREQ        reduce using rule 63 (expression -> NUMBERvar .)
    SEMICOLON       reduce using rule 63 (expression -> NUMBERvar .)
    LOGOR           reduce using rule 63 (expression -> NUMBERvar .)
    LOGAND          reduce using rule 63 (expression -> NUMBERvar .)


state 94

    (62) expression -> var .

    RPAREN          reduce using rule 62 (expression -> var .)
    PLUS            reduce using rule 62 (expression -> var .)
    MINUS           reduce using rule 62 (expression -> var .)
    ASTERISK        reduce using rule 62 (expression -> var .)
    DIVIDE          reduce using rule 62 (expression -> var .)
    EQUALS          reduce using rule 62 (expression -> var .)
    NOTEQUAL        reduce using rule 62 (expression -> var .)
    GREATER         reduce using rule 62 (expression -> var .)
    LESSER          reduce using rule 62 (expression -> var .)
    GREATEREQ       reduce using rule 62 (expression -> var .)
    LESSEREQ        reduce using rule 62 (expression -> var .)
    SEMICOLON       reduce using rule 62 (expression -> var .)
    LOGOR           reduce using rule 62 (expression -> var .)
    LOGAND          reduce using rule 62 (expression -> var .)


state 95

    (66) NUMBERvar -> NUMBER2 .

    PLUS            reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    MINUS           reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    ASTERISK        reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    DIVIDE          reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    RPAREN          reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    LOGOR           reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    LOGAND          reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    EQUALS          reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    NOTEQUAL        reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    GREATER         reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    LESSER          reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    GREATEREQ       reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    LESSEREQ        reduce using rule 66 (NUMBERvar -> NUMBER2 .)
    SEMICOLON       reduce using rule 66 (NUMBERvar -> NUMBER2 .)


state 96

    (78) b_expression -> expression . sign1 expression
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression
    (81) sign1 -> . EQUALS
    (82) sign1 -> . NOTEQUAL
    (83) sign1 -> . GREATER
    (84) sign1 -> . LESSER
    (85) sign1 -> . GREATEREQ
    (86) sign1 -> . LESSEREQ

    PLUS            shift and go to state 130
    MINUS           shift and go to state 132
    ASTERISK        shift and go to state 126
    DIVIDE          shift and go to state 124
    EQUALS          shift and go to state 127
    NOTEQUAL        shift and go to state 123
    GREATER         shift and go to state 133
    LESSER          shift and go to state 128
    GREATEREQ       shift and go to state 129
    LESSEREQ        shift and go to state 125

    sign1                          shift and go to state 131

state 97

    (70) expression -> MINUS . expression
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 100
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    var                            shift and go to state 94
    expression                     shift and go to state 134
    NUMBERvar                      shift and go to state 93

state 98

    (23) function_call -> NAME . LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> NAME . LPAREN RPAREN SEMICOLON
    (69) var -> NAME .

    LPAREN          shift and go to state 66
    SEMICOLON       reduce using rule 69 (var -> NAME .)
    PLUS            reduce using rule 69 (var -> NAME .)
    MINUS           reduce using rule 69 (var -> NAME .)
    ASTERISK        reduce using rule 69 (var -> NAME .)
    DIVIDE          reduce using rule 69 (var -> NAME .)


state 99

    (54) assignment_statement -> LEFT EQUAL function_call .

    WHILE           reduce using rule 54 (assignment_statement -> LEFT EQUAL function_call .)
    IF              reduce using rule 54 (assignment_statement -> LEFT EQUAL function_call .)
    NAME            reduce using rule 54 (assignment_statement -> LEFT EQUAL function_call .)
    ASTERISK        reduce using rule 54 (assignment_statement -> LEFT EQUAL function_call .)
    INT             reduce using rule 54 (assignment_statement -> LEFT EQUAL function_call .)
    FLOAT           reduce using rule 54 (assignment_statement -> LEFT EQUAL function_call .)
    RETURN          reduce using rule 54 (assignment_statement -> LEFT EQUAL function_call .)
    RBRACE          reduce using rule 54 (assignment_statement -> LEFT EQUAL function_call .)
    ELSE            reduce using rule 54 (assignment_statement -> LEFT EQUAL function_call .)


state 100

    (64) expression -> LPAREN . expression RPAREN
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 100
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    var                            shift and go to state 94
    expression                     shift and go to state 135
    NUMBERvar                      shift and go to state 93

state 101

    (52) assignment_statement -> LEFT EQUAL expression . SEMICOLON
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 136
    PLUS            shift and go to state 130
    MINUS           shift and go to state 132
    ASTERISK        shift and go to state 126
    DIVIDE          shift and go to state 124


state 102

    (68) var -> AMPERSAND var .

    EQUAL           reduce using rule 68 (var -> AMPERSAND var .)
    COMMA           reduce using rule 68 (var -> AMPERSAND var .)
    RPAREN          reduce using rule 68 (var -> AMPERSAND var .)
    SEMICOLON       reduce using rule 68 (var -> AMPERSAND var .)
    PLUS            reduce using rule 68 (var -> AMPERSAND var .)
    MINUS           reduce using rule 68 (var -> AMPERSAND var .)
    ASTERISK        reduce using rule 68 (var -> AMPERSAND var .)
    DIVIDE          reduce using rule 68 (var -> AMPERSAND var .)
    EQUALS          reduce using rule 68 (var -> AMPERSAND var .)
    NOTEQUAL        reduce using rule 68 (var -> AMPERSAND var .)
    GREATER         reduce using rule 68 (var -> AMPERSAND var .)
    LESSER          reduce using rule 68 (var -> AMPERSAND var .)
    GREATEREQ       reduce using rule 68 (var -> AMPERSAND var .)
    LESSEREQ        reduce using rule 68 (var -> AMPERSAND var .)
    LOGOR           reduce using rule 68 (var -> AMPERSAND var .)
    LOGAND          reduce using rule 68 (var -> AMPERSAND var .)


state 103

    (67) var -> ASTERISK var .

    EQUAL           reduce using rule 67 (var -> ASTERISK var .)
    COMMA           reduce using rule 67 (var -> ASTERISK var .)
    RPAREN          reduce using rule 67 (var -> ASTERISK var .)
    SEMICOLON       reduce using rule 67 (var -> ASTERISK var .)
    PLUS            reduce using rule 67 (var -> ASTERISK var .)
    MINUS           reduce using rule 67 (var -> ASTERISK var .)
    ASTERISK        reduce using rule 67 (var -> ASTERISK var .)
    DIVIDE          reduce using rule 67 (var -> ASTERISK var .)
    EQUALS          reduce using rule 67 (var -> ASTERISK var .)
    NOTEQUAL        reduce using rule 67 (var -> ASTERISK var .)
    GREATER         reduce using rule 67 (var -> ASTERISK var .)
    LESSER          reduce using rule 67 (var -> ASTERISK var .)
    GREATEREQ       reduce using rule 67 (var -> ASTERISK var .)
    LESSEREQ        reduce using rule 67 (var -> ASTERISK var .)
    LOGOR           reduce using rule 67 (var -> ASTERISK var .)
    LOGAND          reduce using rule 67 (var -> ASTERISK var .)


state 104

    (51) assignment_statement -> ID EQUAL RIGHT . SEMICOLON

    SEMICOLON       shift and go to state 137


state 105

    (23) function_call -> NAME . LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> NAME . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 66


state 106

    (53) assignment_statement -> ID EQUAL function_call .

    WHILE           reduce using rule 53 (assignment_statement -> ID EQUAL function_call .)
    IF              reduce using rule 53 (assignment_statement -> ID EQUAL function_call .)
    NAME            reduce using rule 53 (assignment_statement -> ID EQUAL function_call .)
    ASTERISK        reduce using rule 53 (assignment_statement -> ID EQUAL function_call .)
    INT             reduce using rule 53 (assignment_statement -> ID EQUAL function_call .)
    FLOAT           reduce using rule 53 (assignment_statement -> ID EQUAL function_call .)
    RETURN          reduce using rule 53 (assignment_statement -> ID EQUAL function_call .)
    RBRACE          reduce using rule 53 (assignment_statement -> ID EQUAL function_call .)
    ELSE            reduce using rule 53 (assignment_statement -> ID EQUAL function_call .)


state 107

    (57) RIGHT -> AMPERSAND . var
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME

    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75

    var                            shift and go to state 138

state 108

    (76) if_stat -> IF LPAREN b_expression . RPAREN code_block
    (77) if_stat -> IF LPAREN b_expression . RPAREN code_block ELSE code_block
    (79) b_expression -> b_expression . sign2 b_expression
    (87) sign2 -> . LOGOR
    (88) sign2 -> . LOGAND

    RPAREN          shift and go to state 139
    LOGOR           shift and go to state 117
    LOGAND          shift and go to state 119

    sign2                          shift and go to state 120

state 109

    (17) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat . RBRACE

    RBRACE          shift and go to state 140


state 110

    (19) return_stat -> RETURN . LEFT SEMICOLON
    (20) return_stat -> RETURN . ID SEMICOLON
    (56) LEFT -> . ASTERISK var
    (55) ID -> . NAME

    ASTERISK        shift and go to state 54
    NAME            shift and go to state 86

    ID                             shift and go to state 141
    LEFT                           shift and go to state 142

state 111

    (21) return_stat2 -> RETURN SEMICOLON .

    RBRACE          reduce using rule 21 (return_stat2 -> RETURN SEMICOLON .)


state 112

    (18) function_body -> VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE .

    VOID            reduce using rule 18 (function_body -> VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE .)
    INT             reduce using rule 18 (function_body -> VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE .)
    FLOAT           reduce using rule 18 (function_body -> VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE .)
    $end            reduce using rule 18 (function_body -> VOID namevar LPAREN arguments RPAREN LBRACE function_content return_stat2 RBRACE .)


state 113

    (24) function_call -> NAME LPAREN RPAREN SEMICOLON .

    WHILE           reduce using rule 24 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 24 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    NAME            reduce using rule 24 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    ASTERISK        reduce using rule 24 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 24 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 24 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 24 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 24 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    ELSE            reduce using rule 24 (function_call -> NAME LPAREN RPAREN SEMICOLON .)


state 114

    (23) function_call -> NAME LPAREN arglist RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 143


state 115

    (28) arglist -> ID COMMA . arglist
    (25) arglist -> . LEFT
    (26) arglist -> . ID
    (27) arglist -> . LEFT COMMA arglist
    (28) arglist -> . ID COMMA arglist
    (56) LEFT -> . ASTERISK var
    (55) ID -> . NAME

    ASTERISK        shift and go to state 54
    NAME            shift and go to state 86

    arglist                        shift and go to state 144
    ID                             shift and go to state 88
    LEFT                           shift and go to state 89

state 116

    (27) arglist -> LEFT COMMA . arglist
    (25) arglist -> . LEFT
    (26) arglist -> . ID
    (27) arglist -> . LEFT COMMA arglist
    (28) arglist -> . ID COMMA arglist
    (56) LEFT -> . ASTERISK var
    (55) ID -> . NAME

    ASTERISK        shift and go to state 54
    NAME            shift and go to state 86

    arglist                        shift and go to state 145
    ID                             shift and go to state 88
    LEFT                           shift and go to state 89

state 117

    (87) sign2 -> LOGOR .

    LPAREN          reduce using rule 87 (sign2 -> LOGOR .)
    MINUS           reduce using rule 87 (sign2 -> LOGOR .)
    ASTERISK        reduce using rule 87 (sign2 -> LOGOR .)
    AMPERSAND       reduce using rule 87 (sign2 -> LOGOR .)
    NAME            reduce using rule 87 (sign2 -> LOGOR .)
    NUMBER          reduce using rule 87 (sign2 -> LOGOR .)
    NUMBER2         reduce using rule 87 (sign2 -> LOGOR .)


state 118

    (75) while_stat -> WHILE LPAREN b_expression RPAREN . code_block
    (71) code_block -> . if_stat
    (72) code_block -> . while_stat
    (73) code_block -> . assignment_statement
    (74) code_block -> . LBRACE function_content RBRACE
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var

    LBRACE          shift and go to state 146
    IF              shift and go to state 57
    WHILE           shift and go to state 49
    NAME            shift and go to state 86
    ASTERISK        shift and go to state 54

    code_block                     shift and go to state 149
    while_stat                     shift and go to state 150
    if_stat                        shift and go to state 148
    assignment_statement           shift and go to state 147
    LEFT                           shift and go to state 52
    ID                             shift and go to state 56

state 119

    (88) sign2 -> LOGAND .

    LPAREN          reduce using rule 88 (sign2 -> LOGAND .)
    MINUS           reduce using rule 88 (sign2 -> LOGAND .)
    ASTERISK        reduce using rule 88 (sign2 -> LOGAND .)
    AMPERSAND       reduce using rule 88 (sign2 -> LOGAND .)
    NAME            reduce using rule 88 (sign2 -> LOGAND .)
    NUMBER          reduce using rule 88 (sign2 -> LOGAND .)
    NUMBER2         reduce using rule 88 (sign2 -> LOGAND .)


state 120

    (79) b_expression -> b_expression sign2 . b_expression
    (78) b_expression -> . expression sign1 expression
    (79) b_expression -> . b_expression sign2 b_expression
    (80) b_expression -> . LPAREN b_expression RPAREN
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 92
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    b_expression                   shift and go to state 151
    NUMBERvar                      shift and go to state 93
    var                            shift and go to state 94
    expression                     shift and go to state 96

state 121

    (80) b_expression -> LPAREN b_expression . RPAREN
    (79) b_expression -> b_expression . sign2 b_expression
    (87) sign2 -> . LOGOR
    (88) sign2 -> . LOGAND

    RPAREN          shift and go to state 152
    LOGOR           shift and go to state 117
    LOGAND          shift and go to state 119

    sign2                          shift and go to state 120

state 122

    (64) expression -> LPAREN expression . RPAREN
    (78) b_expression -> expression . sign1 expression
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression
    (81) sign1 -> . EQUALS
    (82) sign1 -> . NOTEQUAL
    (83) sign1 -> . GREATER
    (84) sign1 -> . LESSER
    (85) sign1 -> . GREATEREQ
    (86) sign1 -> . LESSEREQ

    RPAREN          shift and go to state 153
    PLUS            shift and go to state 130
    MINUS           shift and go to state 132
    ASTERISK        shift and go to state 126
    DIVIDE          shift and go to state 124
    EQUALS          shift and go to state 127
    NOTEQUAL        shift and go to state 123
    GREATER         shift and go to state 133
    LESSER          shift and go to state 128
    GREATEREQ       shift and go to state 129
    LESSEREQ        shift and go to state 125

    sign1                          shift and go to state 131

state 123

    (82) sign1 -> NOTEQUAL .

    LPAREN          reduce using rule 82 (sign1 -> NOTEQUAL .)
    MINUS           reduce using rule 82 (sign1 -> NOTEQUAL .)
    ASTERISK        reduce using rule 82 (sign1 -> NOTEQUAL .)
    AMPERSAND       reduce using rule 82 (sign1 -> NOTEQUAL .)
    NAME            reduce using rule 82 (sign1 -> NOTEQUAL .)
    NUMBER          reduce using rule 82 (sign1 -> NOTEQUAL .)
    NUMBER2         reduce using rule 82 (sign1 -> NOTEQUAL .)


state 124

    (61) expression -> expression DIVIDE . expression
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 100
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    var                            shift and go to state 94
    expression                     shift and go to state 154
    NUMBERvar                      shift and go to state 93

state 125

    (86) sign1 -> LESSEREQ .

    LPAREN          reduce using rule 86 (sign1 -> LESSEREQ .)
    MINUS           reduce using rule 86 (sign1 -> LESSEREQ .)
    ASTERISK        reduce using rule 86 (sign1 -> LESSEREQ .)
    AMPERSAND       reduce using rule 86 (sign1 -> LESSEREQ .)
    NAME            reduce using rule 86 (sign1 -> LESSEREQ .)
    NUMBER          reduce using rule 86 (sign1 -> LESSEREQ .)
    NUMBER2         reduce using rule 86 (sign1 -> LESSEREQ .)


state 126

    (60) expression -> expression ASTERISK . expression
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 100
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    var                            shift and go to state 94
    expression                     shift and go to state 155
    NUMBERvar                      shift and go to state 93

state 127

    (81) sign1 -> EQUALS .

    LPAREN          reduce using rule 81 (sign1 -> EQUALS .)
    MINUS           reduce using rule 81 (sign1 -> EQUALS .)
    ASTERISK        reduce using rule 81 (sign1 -> EQUALS .)
    AMPERSAND       reduce using rule 81 (sign1 -> EQUALS .)
    NAME            reduce using rule 81 (sign1 -> EQUALS .)
    NUMBER          reduce using rule 81 (sign1 -> EQUALS .)
    NUMBER2         reduce using rule 81 (sign1 -> EQUALS .)


state 128

    (84) sign1 -> LESSER .

    LPAREN          reduce using rule 84 (sign1 -> LESSER .)
    MINUS           reduce using rule 84 (sign1 -> LESSER .)
    ASTERISK        reduce using rule 84 (sign1 -> LESSER .)
    AMPERSAND       reduce using rule 84 (sign1 -> LESSER .)
    NAME            reduce using rule 84 (sign1 -> LESSER .)
    NUMBER          reduce using rule 84 (sign1 -> LESSER .)
    NUMBER2         reduce using rule 84 (sign1 -> LESSER .)


state 129

    (85) sign1 -> GREATEREQ .

    LPAREN          reduce using rule 85 (sign1 -> GREATEREQ .)
    MINUS           reduce using rule 85 (sign1 -> GREATEREQ .)
    ASTERISK        reduce using rule 85 (sign1 -> GREATEREQ .)
    AMPERSAND       reduce using rule 85 (sign1 -> GREATEREQ .)
    NAME            reduce using rule 85 (sign1 -> GREATEREQ .)
    NUMBER          reduce using rule 85 (sign1 -> GREATEREQ .)
    NUMBER2         reduce using rule 85 (sign1 -> GREATEREQ .)


state 130

    (58) expression -> expression PLUS . expression
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 100
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    var                            shift and go to state 94
    expression                     shift and go to state 156
    NUMBERvar                      shift and go to state 93

state 131

    (78) b_expression -> expression sign1 . expression
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 100
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    var                            shift and go to state 94
    expression                     shift and go to state 157
    NUMBERvar                      shift and go to state 93

state 132

    (59) expression -> expression MINUS . expression
    (58) expression -> . expression PLUS expression
    (59) expression -> . expression MINUS expression
    (60) expression -> . expression ASTERISK expression
    (61) expression -> . expression DIVIDE expression
    (62) expression -> . var
    (63) expression -> . NUMBERvar
    (64) expression -> . LPAREN expression RPAREN
    (70) expression -> . MINUS expression
    (67) var -> . ASTERISK var
    (68) var -> . AMPERSAND var
    (69) var -> . NAME
    (65) NUMBERvar -> . NUMBER
    (66) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 100
    MINUS           shift and go to state 97
    ASTERISK        shift and go to state 74
    AMPERSAND       shift and go to state 73
    NAME            shift and go to state 75
    NUMBER          shift and go to state 90
    NUMBER2         shift and go to state 95

    var                            shift and go to state 94
    expression                     shift and go to state 158
    NUMBERvar                      shift and go to state 93

state 133

    (83) sign1 -> GREATER .

    LPAREN          reduce using rule 83 (sign1 -> GREATER .)
    MINUS           reduce using rule 83 (sign1 -> GREATER .)
    ASTERISK        reduce using rule 83 (sign1 -> GREATER .)
    AMPERSAND       reduce using rule 83 (sign1 -> GREATER .)
    NAME            reduce using rule 83 (sign1 -> GREATER .)
    NUMBER          reduce using rule 83 (sign1 -> GREATER .)
    NUMBER2         reduce using rule 83 (sign1 -> GREATER .)


state 134

    (70) expression -> MINUS expression .
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 70 (expression -> MINUS expression .)
    PLUS            reduce using rule 70 (expression -> MINUS expression .)
    MINUS           reduce using rule 70 (expression -> MINUS expression .)
    ASTERISK        reduce using rule 70 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 70 (expression -> MINUS expression .)
    EQUALS          reduce using rule 70 (expression -> MINUS expression .)
    NOTEQUAL        reduce using rule 70 (expression -> MINUS expression .)
    GREATER         reduce using rule 70 (expression -> MINUS expression .)
    LESSER          reduce using rule 70 (expression -> MINUS expression .)
    GREATEREQ       reduce using rule 70 (expression -> MINUS expression .)
    LESSEREQ        reduce using rule 70 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 70 (expression -> MINUS expression .)
    LOGOR           reduce using rule 70 (expression -> MINUS expression .)
    LOGAND          reduce using rule 70 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 130 ]
  ! MINUS           [ shift and go to state 132 ]
  ! ASTERISK        [ shift and go to state 126 ]
  ! DIVIDE          [ shift and go to state 124 ]


state 135

    (64) expression -> LPAREN expression . RPAREN
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 153
    PLUS            shift and go to state 130
    MINUS           shift and go to state 132
    ASTERISK        shift and go to state 126
    DIVIDE          shift and go to state 124


state 136

    (52) assignment_statement -> LEFT EQUAL expression SEMICOLON .

    WHILE           reduce using rule 52 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    IF              reduce using rule 52 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    NAME            reduce using rule 52 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    ASTERISK        reduce using rule 52 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    INT             reduce using rule 52 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 52 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 52 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 52 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    ELSE            reduce using rule 52 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)


state 137

    (51) assignment_statement -> ID EQUAL RIGHT SEMICOLON .

    WHILE           reduce using rule 51 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    IF              reduce using rule 51 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    NAME            reduce using rule 51 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    ASTERISK        reduce using rule 51 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    INT             reduce using rule 51 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    FLOAT           reduce using rule 51 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    RETURN          reduce using rule 51 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    RBRACE          reduce using rule 51 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    ELSE            reduce using rule 51 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)


state 138

    (57) RIGHT -> AMPERSAND var .

    SEMICOLON       reduce using rule 57 (RIGHT -> AMPERSAND var .)


state 139

    (76) if_stat -> IF LPAREN b_expression RPAREN . code_block
    (77) if_stat -> IF LPAREN b_expression RPAREN . code_block ELSE code_block
    (71) code_block -> . if_stat
    (72) code_block -> . while_stat
    (73) code_block -> . assignment_statement
    (74) code_block -> . LBRACE function_content RBRACE
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var

    LBRACE          shift and go to state 146
    IF              shift and go to state 57
    WHILE           shift and go to state 49
    NAME            shift and go to state 86
    ASTERISK        shift and go to state 54

    code_block                     shift and go to state 159
    while_stat                     shift and go to state 150
    if_stat                        shift and go to state 148
    assignment_statement           shift and go to state 147
    LEFT                           shift and go to state 52
    ID                             shift and go to state 56

state 140

    (17) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .

    VOID            reduce using rule 17 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    INT             reduce using rule 17 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    FLOAT           reduce using rule 17 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    $end            reduce using rule 17 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)


state 141

    (20) return_stat -> RETURN ID . SEMICOLON

    SEMICOLON       shift and go to state 160


state 142

    (19) return_stat -> RETURN LEFT . SEMICOLON

    SEMICOLON       shift and go to state 161


state 143

    (23) function_call -> NAME LPAREN arglist RPAREN SEMICOLON .

    WHILE           reduce using rule 23 (function_call -> NAME LPAREN arglist RPAREN SEMICOLON .)
    IF              reduce using rule 23 (function_call -> NAME LPAREN arglist RPAREN SEMICOLON .)
    NAME            reduce using rule 23 (function_call -> NAME LPAREN arglist RPAREN SEMICOLON .)
    ASTERISK        reduce using rule 23 (function_call -> NAME LPAREN arglist RPAREN SEMICOLON .)
    INT             reduce using rule 23 (function_call -> NAME LPAREN arglist RPAREN SEMICOLON .)
    FLOAT           reduce using rule 23 (function_call -> NAME LPAREN arglist RPAREN SEMICOLON .)
    RETURN          reduce using rule 23 (function_call -> NAME LPAREN arglist RPAREN SEMICOLON .)
    RBRACE          reduce using rule 23 (function_call -> NAME LPAREN arglist RPAREN SEMICOLON .)
    ELSE            reduce using rule 23 (function_call -> NAME LPAREN arglist RPAREN SEMICOLON .)


state 144

    (28) arglist -> ID COMMA arglist .

    RPAREN          reduce using rule 28 (arglist -> ID COMMA arglist .)


state 145

    (27) arglist -> LEFT COMMA arglist .

    RPAREN          reduce using rule 27 (arglist -> LEFT COMMA arglist .)


state 146

    (74) code_block -> LBRACE . function_content RBRACE
    (30) function_content -> . assignment_statement
    (31) function_content -> . while_stat
    (32) function_content -> . if_stat
    (33) function_content -> . function_call
    (34) function_content -> . assignment_statement function_content
    (35) function_content -> . while_stat function_content
    (36) function_content -> . if_stat function_content
    (37) function_content -> . function_call function_content
    (38) function_content -> . declaration
    (39) function_content -> . declaration function_content
    (40) function_content -> . epsilon
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (23) function_call -> . NAME LPAREN arglist RPAREN SEMICOLON
    (24) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (41) declaration -> . datatype varlist SEMICOLON
    (89) epsilon -> .
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var
    (42) datatype -> . INT
    (43) datatype -> . FLOAT

    WHILE           shift and go to state 49
    IF              shift and go to state 57
    NAME            shift and go to state 47
    RBRACE          reduce using rule 89 (epsilon -> .)
    ASTERISK        shift and go to state 54
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    epsilon                        shift and go to state 53
    function_content               shift and go to state 162
    while_stat                     shift and go to state 59
    datatype                       shift and go to state 60
    if_stat                        shift and go to state 51
    assignment_statement           shift and go to state 50
    function_call                  shift and go to state 48
    declaration                    shift and go to state 55
    ID                             shift and go to state 56
    LEFT                           shift and go to state 52

state 147

    (73) code_block -> assignment_statement .

    WHILE           reduce using rule 73 (code_block -> assignment_statement .)
    IF              reduce using rule 73 (code_block -> assignment_statement .)
    NAME            reduce using rule 73 (code_block -> assignment_statement .)
    ASTERISK        reduce using rule 73 (code_block -> assignment_statement .)
    INT             reduce using rule 73 (code_block -> assignment_statement .)
    FLOAT           reduce using rule 73 (code_block -> assignment_statement .)
    RBRACE          reduce using rule 73 (code_block -> assignment_statement .)
    RETURN          reduce using rule 73 (code_block -> assignment_statement .)
    ELSE            reduce using rule 73 (code_block -> assignment_statement .)


state 148

    (71) code_block -> if_stat .

    WHILE           reduce using rule 71 (code_block -> if_stat .)
    IF              reduce using rule 71 (code_block -> if_stat .)
    NAME            reduce using rule 71 (code_block -> if_stat .)
    ASTERISK        reduce using rule 71 (code_block -> if_stat .)
    INT             reduce using rule 71 (code_block -> if_stat .)
    FLOAT           reduce using rule 71 (code_block -> if_stat .)
    RBRACE          reduce using rule 71 (code_block -> if_stat .)
    RETURN          reduce using rule 71 (code_block -> if_stat .)
    ELSE            reduce using rule 71 (code_block -> if_stat .)


state 149

    (75) while_stat -> WHILE LPAREN b_expression RPAREN code_block .

    WHILE           reduce using rule 75 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    IF              reduce using rule 75 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    NAME            reduce using rule 75 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    ASTERISK        reduce using rule 75 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    INT             reduce using rule 75 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    FLOAT           reduce using rule 75 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    RBRACE          reduce using rule 75 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    RETURN          reduce using rule 75 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    ELSE            reduce using rule 75 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)


state 150

    (72) code_block -> while_stat .

    WHILE           reduce using rule 72 (code_block -> while_stat .)
    IF              reduce using rule 72 (code_block -> while_stat .)
    NAME            reduce using rule 72 (code_block -> while_stat .)
    ASTERISK        reduce using rule 72 (code_block -> while_stat .)
    INT             reduce using rule 72 (code_block -> while_stat .)
    FLOAT           reduce using rule 72 (code_block -> while_stat .)
    RBRACE          reduce using rule 72 (code_block -> while_stat .)
    RETURN          reduce using rule 72 (code_block -> while_stat .)
    ELSE            reduce using rule 72 (code_block -> while_stat .)


state 151

    (79) b_expression -> b_expression sign2 b_expression .
    (79) b_expression -> b_expression . sign2 b_expression
    (87) sign2 -> . LOGOR
    (88) sign2 -> . LOGAND

  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
    RPAREN          reduce using rule 79 (b_expression -> b_expression sign2 b_expression .)
    LOGOR           shift and go to state 117
    LOGAND          shift and go to state 119

  ! LOGOR           [ reduce using rule 79 (b_expression -> b_expression sign2 b_expression .) ]
  ! LOGAND          [ reduce using rule 79 (b_expression -> b_expression sign2 b_expression .) ]

    sign2                          shift and go to state 120

state 152

    (80) b_expression -> LPAREN b_expression RPAREN .

    RPAREN          reduce using rule 80 (b_expression -> LPAREN b_expression RPAREN .)
    LOGOR           reduce using rule 80 (b_expression -> LPAREN b_expression RPAREN .)
    LOGAND          reduce using rule 80 (b_expression -> LPAREN b_expression RPAREN .)


state 153

    (64) expression -> LPAREN expression RPAREN .

    RPAREN          reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    ASTERISK        reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    EQUALS          reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    LESSER          reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    LESSEREQ        reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    LOGOR           reduce using rule 64 (expression -> LPAREN expression RPAREN .)
    LOGAND          reduce using rule 64 (expression -> LPAREN expression RPAREN .)


state 154

    (61) expression -> expression DIVIDE expression .
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 61 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 61 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 61 (expression -> expression DIVIDE expression .)
    ASTERISK        reduce using rule 61 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 61 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 61 (expression -> expression DIVIDE expression .)
    NOTEQUAL        reduce using rule 61 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 61 (expression -> expression DIVIDE expression .)
    LESSER          reduce using rule 61 (expression -> expression DIVIDE expression .)
    GREATEREQ       reduce using rule 61 (expression -> expression DIVIDE expression .)
    LESSEREQ        reduce using rule 61 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 61 (expression -> expression DIVIDE expression .)
    LOGOR           reduce using rule 61 (expression -> expression DIVIDE expression .)
    LOGAND          reduce using rule 61 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 130 ]
  ! MINUS           [ shift and go to state 132 ]
  ! ASTERISK        [ shift and go to state 126 ]
  ! DIVIDE          [ shift and go to state 124 ]


state 155

    (60) expression -> expression ASTERISK expression .
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 60 (expression -> expression ASTERISK expression .)
    PLUS            reduce using rule 60 (expression -> expression ASTERISK expression .)
    MINUS           reduce using rule 60 (expression -> expression ASTERISK expression .)
    ASTERISK        reduce using rule 60 (expression -> expression ASTERISK expression .)
    DIVIDE          reduce using rule 60 (expression -> expression ASTERISK expression .)
    EQUALS          reduce using rule 60 (expression -> expression ASTERISK expression .)
    NOTEQUAL        reduce using rule 60 (expression -> expression ASTERISK expression .)
    GREATER         reduce using rule 60 (expression -> expression ASTERISK expression .)
    LESSER          reduce using rule 60 (expression -> expression ASTERISK expression .)
    GREATEREQ       reduce using rule 60 (expression -> expression ASTERISK expression .)
    LESSEREQ        reduce using rule 60 (expression -> expression ASTERISK expression .)
    SEMICOLON       reduce using rule 60 (expression -> expression ASTERISK expression .)
    LOGOR           reduce using rule 60 (expression -> expression ASTERISK expression .)
    LOGAND          reduce using rule 60 (expression -> expression ASTERISK expression .)

  ! PLUS            [ shift and go to state 130 ]
  ! MINUS           [ shift and go to state 132 ]
  ! ASTERISK        [ shift and go to state 126 ]
  ! DIVIDE          [ shift and go to state 124 ]


state 156

    (58) expression -> expression PLUS expression .
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 58 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 58 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 58 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 58 (expression -> expression PLUS expression .)
    NOTEQUAL        reduce using rule 58 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 58 (expression -> expression PLUS expression .)
    LESSER          reduce using rule 58 (expression -> expression PLUS expression .)
    GREATEREQ       reduce using rule 58 (expression -> expression PLUS expression .)
    LESSEREQ        reduce using rule 58 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 58 (expression -> expression PLUS expression .)
    LOGOR           reduce using rule 58 (expression -> expression PLUS expression .)
    LOGAND          reduce using rule 58 (expression -> expression PLUS expression .)
    ASTERISK        shift and go to state 126
    DIVIDE          shift and go to state 124

  ! ASTERISK        [ reduce using rule 58 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 58 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 130 ]
  ! MINUS           [ shift and go to state 132 ]


state 157

    (78) b_expression -> expression sign1 expression .
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 78 (b_expression -> expression sign1 expression .)
    LOGOR           reduce using rule 78 (b_expression -> expression sign1 expression .)
    LOGAND          reduce using rule 78 (b_expression -> expression sign1 expression .)
    PLUS            shift and go to state 130
    MINUS           shift and go to state 132
    ASTERISK        shift and go to state 126
    DIVIDE          shift and go to state 124


state 158

    (59) expression -> expression MINUS expression .
    (58) expression -> expression . PLUS expression
    (59) expression -> expression . MINUS expression
    (60) expression -> expression . ASTERISK expression
    (61) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 59 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 59 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 59 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 59 (expression -> expression MINUS expression .)
    NOTEQUAL        reduce using rule 59 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 59 (expression -> expression MINUS expression .)
    LESSER          reduce using rule 59 (expression -> expression MINUS expression .)
    GREATEREQ       reduce using rule 59 (expression -> expression MINUS expression .)
    LESSEREQ        reduce using rule 59 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 59 (expression -> expression MINUS expression .)
    LOGOR           reduce using rule 59 (expression -> expression MINUS expression .)
    LOGAND          reduce using rule 59 (expression -> expression MINUS expression .)
    ASTERISK        shift and go to state 126
    DIVIDE          shift and go to state 124

  ! ASTERISK        [ reduce using rule 59 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 59 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 130 ]
  ! MINUS           [ shift and go to state 132 ]


state 159

    (76) if_stat -> IF LPAREN b_expression RPAREN code_block .
    (77) if_stat -> IF LPAREN b_expression RPAREN code_block . ELSE code_block

    WHILE           reduce using rule 76 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    IF              reduce using rule 76 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    NAME            reduce using rule 76 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    ASTERISK        reduce using rule 76 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    INT             reduce using rule 76 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    FLOAT           reduce using rule 76 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    RETURN          reduce using rule 76 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    RBRACE          reduce using rule 76 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    ELSE            shift and go to state 163

  ! ELSE            [ reduce using rule 76 (if_stat -> IF LPAREN b_expression RPAREN code_block .) ]


state 160

    (20) return_stat -> RETURN ID SEMICOLON .

    RBRACE          reduce using rule 20 (return_stat -> RETURN ID SEMICOLON .)


state 161

    (19) return_stat -> RETURN LEFT SEMICOLON .

    RBRACE          reduce using rule 19 (return_stat -> RETURN LEFT SEMICOLON .)


state 162

    (74) code_block -> LBRACE function_content . RBRACE

    RBRACE          shift and go to state 164


state 163

    (77) if_stat -> IF LPAREN b_expression RPAREN code_block ELSE . code_block
    (71) code_block -> . if_stat
    (72) code_block -> . while_stat
    (73) code_block -> . assignment_statement
    (74) code_block -> . LBRACE function_content RBRACE
    (76) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (77) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (75) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (51) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (52) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (53) assignment_statement -> . ID EQUAL function_call
    (54) assignment_statement -> . LEFT EQUAL function_call
    (55) ID -> . NAME
    (56) LEFT -> . ASTERISK var

    LBRACE          shift and go to state 146
    IF              shift and go to state 57
    WHILE           shift and go to state 49
    NAME            shift and go to state 86
    ASTERISK        shift and go to state 54

    code_block                     shift and go to state 165
    while_stat                     shift and go to state 150
    if_stat                        shift and go to state 148
    assignment_statement           shift and go to state 147
    LEFT                           shift and go to state 52
    ID                             shift and go to state 56

state 164

    (74) code_block -> LBRACE function_content RBRACE .

    WHILE           reduce using rule 74 (code_block -> LBRACE function_content RBRACE .)
    IF              reduce using rule 74 (code_block -> LBRACE function_content RBRACE .)
    NAME            reduce using rule 74 (code_block -> LBRACE function_content RBRACE .)
    ASTERISK        reduce using rule 74 (code_block -> LBRACE function_content RBRACE .)
    INT             reduce using rule 74 (code_block -> LBRACE function_content RBRACE .)
    FLOAT           reduce using rule 74 (code_block -> LBRACE function_content RBRACE .)
    RBRACE          reduce using rule 74 (code_block -> LBRACE function_content RBRACE .)
    RETURN          reduce using rule 74 (code_block -> LBRACE function_content RBRACE .)
    ELSE            reduce using rule 74 (code_block -> LBRACE function_content RBRACE .)


state 165

    (77) if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .

    WHILE           reduce using rule 77 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    IF              reduce using rule 77 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    NAME            reduce using rule 77 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    ASTERISK        reduce using rule 77 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    INT             reduce using rule 77 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    FLOAT           reduce using rule 77 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    RETURN          reduce using rule 77 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    RBRACE          reduce using rule 77 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    ELSE            reduce using rule 77 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGOR in state 151 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 151 resolved as shift
WARNING: reduce/reduce conflict in state 48 resolved using rule (function_content -> function_call)
WARNING: rejected rule (epsilon -> <empty>) in state 48
WARNING: reduce/reduce conflict in state 50 resolved using rule (function_content -> assignment_statement)
WARNING: rejected rule (epsilon -> <empty>) in state 50
WARNING: reduce/reduce conflict in state 51 resolved using rule (function_content -> if_stat)
WARNING: rejected rule (epsilon -> <empty>) in state 51
WARNING: reduce/reduce conflict in state 55 resolved using rule (function_content -> declaration)
WARNING: rejected rule (epsilon -> <empty>) in state 55
WARNING: reduce/reduce conflict in state 59 resolved using rule (function_content -> while_stat)
WARNING: rejected rule (epsilon -> <empty>) in state 59
