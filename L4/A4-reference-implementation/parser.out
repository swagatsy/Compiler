Created by PLY version 3.7 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> final_program
Rule 1     final_program -> program_content
Rule 2     program_content -> function_dec program_content
Rule 3     program_content -> function_body program_content
Rule 4     program_content -> program program_content
Rule 5     program_content -> function_dec
Rule 6     program_content -> function_body
Rule 7     program_content -> program
Rule 8     program_content -> declaration
Rule 9     program_content -> declaration program_content
Rule 10    function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON
Rule 11    function_dec -> datatype namevar LPAREN arguments RPAREN SEMICOLON
Rule 12    function_dec -> datatype pointer LPAREN RPAREN SEMICOLON
Rule 13    function_dec -> datatype namevar LPAREN RPAREN SEMICOLON
Rule 14    arguments -> datatype pointer
Rule 15    arguments -> datatype namevar
Rule 16    arguments -> datatype pointer COMMA arguments
Rule 17    arguments -> datatype namevar COMMA arguments
Rule 18    function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
Rule 19    function_body -> datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
Rule 20    function_body -> datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE
Rule 21    function_body -> datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE
Rule 22    return_stat -> RETURN pointer SEMICOLON
Rule 23    return_stat -> RETURN NAME SEMICOLON
Rule 24    return_stat -> RETURN SEMICOLON
Rule 25    function_call -> NAME LPAREN varlist RPAREN SEMICOLON
Rule 26    function_call -> NAME LPAREN RPAREN SEMICOLON
Rule 27    program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
Rule 28    function_content -> assignment_statement
Rule 29    function_content -> while_stat
Rule 30    function_content -> if_stat
Rule 31    function_content -> function_call
Rule 32    function_content -> assignment_statement function_content
Rule 33    function_content -> while_stat function_content
Rule 34    function_content -> if_stat function_content
Rule 35    function_content -> function_call function_content
Rule 36    function_content -> declaration
Rule 37    function_content -> declaration function_content
Rule 38    declaration -> datatype varlist SEMICOLON
Rule 39    datatype -> INT
Rule 40    datatype -> FLOAT
Rule 41    datatype -> VOID
Rule 42    namevar -> NAME
Rule 43    varlist -> namevar COMMA varlist
Rule 44    varlist -> pointer COMMA varlist
Rule 45    varlist -> namevar
Rule 46    varlist -> pointer
Rule 47    pointer -> ASTERISK pointer
Rule 48    pointer -> ASTERISK namevar
Rule 49    assignment_statement -> ID EQUAL RIGHT SEMICOLON
Rule 50    assignment_statement -> LEFT EQUAL expression SEMICOLON
Rule 51    assignment_statement -> ID EQUAL function_call
Rule 52    assignment_statement -> LEFT EQUAL function_call
Rule 53    ID -> NAME
Rule 54    LEFT -> ASTERISK var
Rule 55    RIGHT -> AMPERSAND var
Rule 56    expression -> expression PLUS expression
Rule 57    expression -> expression MINUS expression
Rule 58    expression -> expression ASTERISK expression
Rule 59    expression -> expression DIVIDE expression
Rule 60    expression -> var
Rule 61    expression -> NUMBERvar
Rule 62    expression -> LPAREN expression RPAREN
Rule 63    NUMBERvar -> NUMBER
Rule 64    NUMBERvar -> NUMBER2
Rule 65    var -> ASTERISK var
Rule 66    var -> AMPERSAND var
Rule 67    var -> NAME
Rule 68    expression -> MINUS expression
Rule 69    code_block -> if_stat
Rule 70    code_block -> while_stat
Rule 71    code_block -> assignment_statement
Rule 72    code_block -> LBRACE function_content RBRACE
Rule 73    while_stat -> WHILE LPAREN b_expression RPAREN code_block
Rule 74    if_stat -> IF LPAREN b_expression RPAREN code_block
Rule 75    if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block
Rule 76    b_expression -> expression sign1 expression
Rule 77    b_expression -> b_expression sign2 b_expression
Rule 78    b_expression -> LPAREN b_expression RPAREN
Rule 79    sign1 -> EQUALS
Rule 80    sign1 -> NOTEQUAL
Rule 81    sign1 -> GREATER
Rule 82    sign1 -> LESSER
Rule 83    sign1 -> GREATEREQ
Rule 84    sign1 -> LESSEREQ
Rule 85    sign2 -> LOGOR
Rule 86    sign2 -> LOGAND

Terminals, with rules where they appear

AMPERSAND            : 55 66
ASTERISK             : 47 48 54 58 65
COMMA                : 16 17 43 44
DIVIDE               : 59
ELSE                 : 75
EQUAL                : 49 50 51 52
EQUALS               : 79
FLOAT                : 40
GREATER              : 81
GREATEREQ            : 83
IF                   : 74 75
INT                  : 39
LBRACE               : 18 19 20 21 27 72
LESSER               : 82
LESSEREQ             : 84
LOGAND               : 86
LOGOR                : 85
LPAREN               : 10 11 12 13 18 19 20 21 25 26 27 62 73 74 75 78
MAIN                 : 27
MINUS                : 57 68
NAME                 : 23 25 26 42 53 67
NOTEQUAL             : 80
NUMBER               : 63
NUMBER2              : 64
PLUS                 : 56
RBRACE               : 18 19 20 21 27 72
RETURN               : 22 23 24
RPAREN               : 10 11 12 13 18 19 20 21 25 26 27 62 73 74 75 78
SEMICOLON            : 10 11 12 13 22 23 24 25 26 38 49 50
VOID                 : 27 41
WHILE                : 73
error                : 

Nonterminals, with rules where they appear

ID                   : 49 51
LEFT                 : 50 52
NUMBERvar            : 61
RIGHT                : 49
arguments            : 10 11 16 17 18 19
assignment_statement : 28 32 71
b_expression         : 73 74 75 77 77 78
code_block           : 73 74 75 75
datatype             : 10 11 12 13 14 15 16 17 18 19 20 21 38
declaration          : 8 9 36 37
expression           : 50 56 56 57 57 58 58 59 59 62 68 76 76
final_program        : 0
function_body        : 3 6
function_call        : 31 35 51 52
function_content     : 18 19 20 21 27 32 33 34 35 37 72
function_dec         : 2 5
if_stat              : 30 34 69
namevar              : 11 13 15 17 19 21 43 45 48
pointer              : 10 12 14 16 18 20 22 44 46 47
program              : 4 7
program_content      : 1 2 3 4 9
return_stat          : 18 19 20 21
sign1                : 76
sign2                : 77
var                  : 54 55 60 65 66
varlist              : 25 38 43 44
while_stat           : 29 33 70

Parsing method: LALR

state 0

    (0) S' -> . final_program
    (1) final_program -> . program_content
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . datatype namevar LPAREN arguments RPAREN SEMICOLON
    (12) function_dec -> . datatype pointer LPAREN RPAREN SEMICOLON
    (13) function_dec -> . datatype namevar LPAREN RPAREN SEMICOLON
    (18) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (19) function_body -> . datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (20) function_body -> . datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (21) function_body -> . datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (27) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (38) declaration -> . datatype varlist SEMICOLON
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    final_program                  shift and go to state 4
    program_content                shift and go to state 7
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 1

    (27) program -> VOID . MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (41) datatype -> VOID .

    MAIN            shift and go to state 11
    ASTERISK        reduce using rule 41 (datatype -> VOID .)
    NAME            reduce using rule 41 (datatype -> VOID .)


state 2

    (3) program_content -> function_body . program_content
    (6) program_content -> function_body .
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . datatype namevar LPAREN arguments RPAREN SEMICOLON
    (12) function_dec -> . datatype pointer LPAREN RPAREN SEMICOLON
    (13) function_dec -> . datatype namevar LPAREN RPAREN SEMICOLON
    (18) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (19) function_body -> . datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (20) function_body -> . datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (21) function_body -> . datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (27) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (38) declaration -> . datatype varlist SEMICOLON
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    $end            reduce using rule 6 (program_content -> function_body .)
    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    program_content                shift and go to state 12
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 3

    (4) program_content -> program . program_content
    (7) program_content -> program .
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . datatype namevar LPAREN arguments RPAREN SEMICOLON
    (12) function_dec -> . datatype pointer LPAREN RPAREN SEMICOLON
    (13) function_dec -> . datatype namevar LPAREN RPAREN SEMICOLON
    (18) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (19) function_body -> . datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (20) function_body -> . datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (21) function_body -> . datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (27) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (38) declaration -> . datatype varlist SEMICOLON
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    $end            reduce using rule 7 (program_content -> program .)
    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    program_content                shift and go to state 13
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 4

    (0) S' -> final_program .



state 5

    (2) program_content -> function_dec . program_content
    (5) program_content -> function_dec .
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . datatype namevar LPAREN arguments RPAREN SEMICOLON
    (12) function_dec -> . datatype pointer LPAREN RPAREN SEMICOLON
    (13) function_dec -> . datatype namevar LPAREN RPAREN SEMICOLON
    (18) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (19) function_body -> . datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (20) function_body -> . datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (21) function_body -> . datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (27) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (38) declaration -> . datatype varlist SEMICOLON
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    $end            reduce using rule 5 (program_content -> function_dec .)
    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    program_content                shift and go to state 14
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 6

    (8) program_content -> declaration .
    (9) program_content -> declaration . program_content
    (2) program_content -> . function_dec program_content
    (3) program_content -> . function_body program_content
    (4) program_content -> . program program_content
    (5) program_content -> . function_dec
    (6) program_content -> . function_body
    (7) program_content -> . program
    (8) program_content -> . declaration
    (9) program_content -> . declaration program_content
    (10) function_dec -> . datatype pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> . datatype namevar LPAREN arguments RPAREN SEMICOLON
    (12) function_dec -> . datatype pointer LPAREN RPAREN SEMICOLON
    (13) function_dec -> . datatype namevar LPAREN RPAREN SEMICOLON
    (18) function_body -> . datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (19) function_body -> . datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (20) function_body -> . datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (21) function_body -> . datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (27) program -> . VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE
    (38) declaration -> . datatype varlist SEMICOLON
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    $end            reduce using rule 8 (program_content -> declaration .)
    VOID            shift and go to state 1
    INT             shift and go to state 10
    FLOAT           shift and go to state 9

    program_content                shift and go to state 15
    datatype                       shift and go to state 8
    function_dec                   shift and go to state 5
    program                        shift and go to state 3
    declaration                    shift and go to state 6
    function_body                  shift and go to state 2

state 7

    (1) final_program -> program_content .

    $end            reduce using rule 1 (final_program -> program_content .)


state 8

    (10) function_dec -> datatype . pointer LPAREN arguments RPAREN SEMICOLON
    (11) function_dec -> datatype . namevar LPAREN arguments RPAREN SEMICOLON
    (12) function_dec -> datatype . pointer LPAREN RPAREN SEMICOLON
    (13) function_dec -> datatype . namevar LPAREN RPAREN SEMICOLON
    (18) function_body -> datatype . pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (19) function_body -> datatype . namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (20) function_body -> datatype . pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (21) function_body -> datatype . namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (38) declaration -> datatype . varlist SEMICOLON
    (47) pointer -> . ASTERISK pointer
    (48) pointer -> . ASTERISK namevar
    (42) namevar -> . NAME
    (43) varlist -> . namevar COMMA varlist
    (44) varlist -> . pointer COMMA varlist
    (45) varlist -> . namevar
    (46) varlist -> . pointer

    ASTERISK        shift and go to state 17
    NAME            shift and go to state 16

    namevar                        shift and go to state 18
    varlist                        shift and go to state 19
    pointer                        shift and go to state 20

state 9

    (40) datatype -> FLOAT .

    ASTERISK        reduce using rule 40 (datatype -> FLOAT .)
    NAME            reduce using rule 40 (datatype -> FLOAT .)


state 10

    (39) datatype -> INT .

    ASTERISK        reduce using rule 39 (datatype -> INT .)
    NAME            reduce using rule 39 (datatype -> INT .)


state 11

    (27) program -> VOID MAIN . LPAREN RPAREN LBRACE function_content RBRACE

    LPAREN          shift and go to state 21


state 12

    (3) program_content -> function_body program_content .

    $end            reduce using rule 3 (program_content -> function_body program_content .)


state 13

    (4) program_content -> program program_content .

    $end            reduce using rule 4 (program_content -> program program_content .)


state 14

    (2) program_content -> function_dec program_content .

    $end            reduce using rule 2 (program_content -> function_dec program_content .)


state 15

    (9) program_content -> declaration program_content .

    $end            reduce using rule 9 (program_content -> declaration program_content .)


state 16

    (42) namevar -> NAME .

    COMMA           reduce using rule 42 (namevar -> NAME .)
    SEMICOLON       reduce using rule 42 (namevar -> NAME .)
    RPAREN          reduce using rule 42 (namevar -> NAME .)
    LPAREN          reduce using rule 42 (namevar -> NAME .)


state 17

    (47) pointer -> ASTERISK . pointer
    (48) pointer -> ASTERISK . namevar
    (47) pointer -> . ASTERISK pointer
    (48) pointer -> . ASTERISK namevar
    (42) namevar -> . NAME

    ASTERISK        shift and go to state 17
    NAME            shift and go to state 16

    pointer                        shift and go to state 22
    namevar                        shift and go to state 23

state 18

    (11) function_dec -> datatype namevar . LPAREN arguments RPAREN SEMICOLON
    (13) function_dec -> datatype namevar . LPAREN RPAREN SEMICOLON
    (19) function_body -> datatype namevar . LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (21) function_body -> datatype namevar . LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (43) varlist -> namevar . COMMA varlist
    (45) varlist -> namevar .

    LPAREN          shift and go to state 25
    COMMA           shift and go to state 24
    SEMICOLON       reduce using rule 45 (varlist -> namevar .)


state 19

    (38) declaration -> datatype varlist . SEMICOLON

    SEMICOLON       shift and go to state 26


state 20

    (10) function_dec -> datatype pointer . LPAREN arguments RPAREN SEMICOLON
    (12) function_dec -> datatype pointer . LPAREN RPAREN SEMICOLON
    (18) function_body -> datatype pointer . LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE
    (20) function_body -> datatype pointer . LPAREN RPAREN LBRACE function_content return_stat RBRACE
    (44) varlist -> pointer . COMMA varlist
    (46) varlist -> pointer .

    LPAREN          shift and go to state 28
    COMMA           shift and go to state 27
    SEMICOLON       reduce using rule 46 (varlist -> pointer .)


state 21

    (27) program -> VOID MAIN LPAREN . RPAREN LBRACE function_content RBRACE

    RPAREN          shift and go to state 29


state 22

    (47) pointer -> ASTERISK pointer .

    COMMA           reduce using rule 47 (pointer -> ASTERISK pointer .)
    SEMICOLON       reduce using rule 47 (pointer -> ASTERISK pointer .)
    RPAREN          reduce using rule 47 (pointer -> ASTERISK pointer .)
    LPAREN          reduce using rule 47 (pointer -> ASTERISK pointer .)


state 23

    (48) pointer -> ASTERISK namevar .

    COMMA           reduce using rule 48 (pointer -> ASTERISK namevar .)
    SEMICOLON       reduce using rule 48 (pointer -> ASTERISK namevar .)
    RPAREN          reduce using rule 48 (pointer -> ASTERISK namevar .)
    LPAREN          reduce using rule 48 (pointer -> ASTERISK namevar .)


state 24

    (43) varlist -> namevar COMMA . varlist
    (43) varlist -> . namevar COMMA varlist
    (44) varlist -> . pointer COMMA varlist
    (45) varlist -> . namevar
    (46) varlist -> . pointer
    (42) namevar -> . NAME
    (47) pointer -> . ASTERISK pointer
    (48) pointer -> . ASTERISK namevar

    NAME            shift and go to state 16
    ASTERISK        shift and go to state 17

    varlist                        shift and go to state 30
    pointer                        shift and go to state 32
    namevar                        shift and go to state 31

state 25

    (11) function_dec -> datatype namevar LPAREN . arguments RPAREN SEMICOLON
    (13) function_dec -> datatype namevar LPAREN . RPAREN SEMICOLON
    (19) function_body -> datatype namevar LPAREN . arguments RPAREN LBRACE function_content return_stat RBRACE
    (21) function_body -> datatype namevar LPAREN . RPAREN LBRACE function_content return_stat RBRACE
    (14) arguments -> . datatype pointer
    (15) arguments -> . datatype namevar
    (16) arguments -> . datatype pointer COMMA arguments
    (17) arguments -> . datatype namevar COMMA arguments
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    RPAREN          shift and go to state 33
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    datatype                       shift and go to state 34
    arguments                      shift and go to state 36

state 26

    (38) declaration -> datatype varlist SEMICOLON .

    WHILE           reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)
    IF              reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)
    NAME            reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)
    ASTERISK        reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)
    INT             reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)
    FLOAT           reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)
    VOID            reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)
    RBRACE          reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)
    RETURN          reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)
    $end            reduce using rule 38 (declaration -> datatype varlist SEMICOLON .)


state 27

    (44) varlist -> pointer COMMA . varlist
    (43) varlist -> . namevar COMMA varlist
    (44) varlist -> . pointer COMMA varlist
    (45) varlist -> . namevar
    (46) varlist -> . pointer
    (42) namevar -> . NAME
    (47) pointer -> . ASTERISK pointer
    (48) pointer -> . ASTERISK namevar

    NAME            shift and go to state 16
    ASTERISK        shift and go to state 17

    varlist                        shift and go to state 37
    pointer                        shift and go to state 32
    namevar                        shift and go to state 31

state 28

    (10) function_dec -> datatype pointer LPAREN . arguments RPAREN SEMICOLON
    (12) function_dec -> datatype pointer LPAREN . RPAREN SEMICOLON
    (18) function_body -> datatype pointer LPAREN . arguments RPAREN LBRACE function_content return_stat RBRACE
    (20) function_body -> datatype pointer LPAREN . RPAREN LBRACE function_content return_stat RBRACE
    (14) arguments -> . datatype pointer
    (15) arguments -> . datatype namevar
    (16) arguments -> . datatype pointer COMMA arguments
    (17) arguments -> . datatype namevar COMMA arguments
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    RPAREN          shift and go to state 38
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    datatype                       shift and go to state 34
    arguments                      shift and go to state 39

state 29

    (27) program -> VOID MAIN LPAREN RPAREN . LBRACE function_content RBRACE

    LBRACE          shift and go to state 40


state 30

    (43) varlist -> namevar COMMA varlist .

    RPAREN          reduce using rule 43 (varlist -> namevar COMMA varlist .)
    SEMICOLON       reduce using rule 43 (varlist -> namevar COMMA varlist .)


state 31

    (43) varlist -> namevar . COMMA varlist
    (45) varlist -> namevar .

    COMMA           shift and go to state 24
    RPAREN          reduce using rule 45 (varlist -> namevar .)
    SEMICOLON       reduce using rule 45 (varlist -> namevar .)


state 32

    (44) varlist -> pointer . COMMA varlist
    (46) varlist -> pointer .

    COMMA           shift and go to state 27
    RPAREN          reduce using rule 46 (varlist -> pointer .)
    SEMICOLON       reduce using rule 46 (varlist -> pointer .)


state 33

    (13) function_dec -> datatype namevar LPAREN RPAREN . SEMICOLON
    (21) function_body -> datatype namevar LPAREN RPAREN . LBRACE function_content return_stat RBRACE

    SEMICOLON       shift and go to state 42
    LBRACE          shift and go to state 41


state 34

    (14) arguments -> datatype . pointer
    (15) arguments -> datatype . namevar
    (16) arguments -> datatype . pointer COMMA arguments
    (17) arguments -> datatype . namevar COMMA arguments
    (47) pointer -> . ASTERISK pointer
    (48) pointer -> . ASTERISK namevar
    (42) namevar -> . NAME

    ASTERISK        shift and go to state 17
    NAME            shift and go to state 16

    pointer                        shift and go to state 44
    namevar                        shift and go to state 43

state 35

    (41) datatype -> VOID .

    ASTERISK        reduce using rule 41 (datatype -> VOID .)
    NAME            reduce using rule 41 (datatype -> VOID .)


state 36

    (11) function_dec -> datatype namevar LPAREN arguments . RPAREN SEMICOLON
    (19) function_body -> datatype namevar LPAREN arguments . RPAREN LBRACE function_content return_stat RBRACE

    RPAREN          shift and go to state 45


state 37

    (44) varlist -> pointer COMMA varlist .

    RPAREN          reduce using rule 44 (varlist -> pointer COMMA varlist .)
    SEMICOLON       reduce using rule 44 (varlist -> pointer COMMA varlist .)


state 38

    (12) function_dec -> datatype pointer LPAREN RPAREN . SEMICOLON
    (20) function_body -> datatype pointer LPAREN RPAREN . LBRACE function_content return_stat RBRACE

    SEMICOLON       shift and go to state 47
    LBRACE          shift and go to state 46


state 39

    (10) function_dec -> datatype pointer LPAREN arguments . RPAREN SEMICOLON
    (18) function_body -> datatype pointer LPAREN arguments . RPAREN LBRACE function_content return_stat RBRACE

    RPAREN          shift and go to state 48


state 40

    (27) program -> VOID MAIN LPAREN RPAREN LBRACE . function_content RBRACE
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    function_content               shift and go to state 59
    while_stat                     shift and go to state 60
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    datatype                       shift and go to state 61
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 41

    (21) function_body -> datatype namevar LPAREN RPAREN LBRACE . function_content return_stat RBRACE
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    function_content               shift and go to state 62
    while_stat                     shift and go to state 60
    datatype                       shift and go to state 61
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 42

    (13) function_dec -> datatype namevar LPAREN RPAREN SEMICOLON .

    VOID            reduce using rule 13 (function_dec -> datatype namevar LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 13 (function_dec -> datatype namevar LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 13 (function_dec -> datatype namevar LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 13 (function_dec -> datatype namevar LPAREN RPAREN SEMICOLON .)


state 43

    (15) arguments -> datatype namevar .
    (17) arguments -> datatype namevar . COMMA arguments

    RPAREN          reduce using rule 15 (arguments -> datatype namevar .)
    COMMA           shift and go to state 63


state 44

    (14) arguments -> datatype pointer .
    (16) arguments -> datatype pointer . COMMA arguments

    RPAREN          reduce using rule 14 (arguments -> datatype pointer .)
    COMMA           shift and go to state 64


state 45

    (11) function_dec -> datatype namevar LPAREN arguments RPAREN . SEMICOLON
    (19) function_body -> datatype namevar LPAREN arguments RPAREN . LBRACE function_content return_stat RBRACE

    SEMICOLON       shift and go to state 66
    LBRACE          shift and go to state 65


state 46

    (20) function_body -> datatype pointer LPAREN RPAREN LBRACE . function_content return_stat RBRACE
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    function_content               shift and go to state 67
    while_stat                     shift and go to state 60
    datatype                       shift and go to state 61
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 47

    (12) function_dec -> datatype pointer LPAREN RPAREN SEMICOLON .

    VOID            reduce using rule 12 (function_dec -> datatype pointer LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 12 (function_dec -> datatype pointer LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 12 (function_dec -> datatype pointer LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 12 (function_dec -> datatype pointer LPAREN RPAREN SEMICOLON .)


state 48

    (10) function_dec -> datatype pointer LPAREN arguments RPAREN . SEMICOLON
    (18) function_body -> datatype pointer LPAREN arguments RPAREN . LBRACE function_content return_stat RBRACE

    SEMICOLON       shift and go to state 69
    LBRACE          shift and go to state 68


state 49

    (25) function_call -> NAME . LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> NAME . LPAREN RPAREN SEMICOLON
    (53) ID -> NAME .

    LPAREN          shift and go to state 70
    EQUAL           reduce using rule 53 (ID -> NAME .)


state 50

    (31) function_content -> function_call .
    (35) function_content -> function_call . function_content
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    RBRACE          reduce using rule 31 (function_content -> function_call .)
    RETURN          reduce using rule 31 (function_content -> function_call .)
    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    function_content               shift and go to state 71
    while_stat                     shift and go to state 60
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    datatype                       shift and go to state 61
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 51

    (73) while_stat -> WHILE . LPAREN b_expression RPAREN code_block

    LPAREN          shift and go to state 72


state 52

    (28) function_content -> assignment_statement .
    (32) function_content -> assignment_statement . function_content
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    RBRACE          reduce using rule 28 (function_content -> assignment_statement .)
    RETURN          reduce using rule 28 (function_content -> assignment_statement .)
    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    function_content               shift and go to state 73
    while_stat                     shift and go to state 60
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    datatype                       shift and go to state 61
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 53

    (50) assignment_statement -> LEFT . EQUAL expression SEMICOLON
    (52) assignment_statement -> LEFT . EQUAL function_call

    EQUAL           shift and go to state 74


state 54

    (30) function_content -> if_stat .
    (34) function_content -> if_stat . function_content
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    RBRACE          reduce using rule 30 (function_content -> if_stat .)
    RETURN          reduce using rule 30 (function_content -> if_stat .)
    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    function_content               shift and go to state 75
    while_stat                     shift and go to state 60
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    datatype                       shift and go to state 61
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 55

    (54) LEFT -> ASTERISK . var
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME

    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79

    var                            shift and go to state 76

state 56

    (36) function_content -> declaration .
    (37) function_content -> declaration . function_content
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    RBRACE          reduce using rule 36 (function_content -> declaration .)
    RETURN          reduce using rule 36 (function_content -> declaration .)
    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    function_content               shift and go to state 80
    while_stat                     shift and go to state 60
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    datatype                       shift and go to state 61
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 57

    (49) assignment_statement -> ID . EQUAL RIGHT SEMICOLON
    (51) assignment_statement -> ID . EQUAL function_call

    EQUAL           shift and go to state 81


state 58

    (74) if_stat -> IF . LPAREN b_expression RPAREN code_block
    (75) if_stat -> IF . LPAREN b_expression RPAREN code_block ELSE code_block

    LPAREN          shift and go to state 82


state 59

    (27) program -> VOID MAIN LPAREN RPAREN LBRACE function_content . RBRACE

    RBRACE          shift and go to state 83


state 60

    (29) function_content -> while_stat .
    (33) function_content -> while_stat . function_content
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    RBRACE          reduce using rule 29 (function_content -> while_stat .)
    RETURN          reduce using rule 29 (function_content -> while_stat .)
    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    while_stat                     shift and go to state 60
    function_content               shift and go to state 84
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    datatype                       shift and go to state 61
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 61

    (38) declaration -> datatype . varlist SEMICOLON
    (43) varlist -> . namevar COMMA varlist
    (44) varlist -> . pointer COMMA varlist
    (45) varlist -> . namevar
    (46) varlist -> . pointer
    (42) namevar -> . NAME
    (47) pointer -> . ASTERISK pointer
    (48) pointer -> . ASTERISK namevar

    NAME            shift and go to state 16
    ASTERISK        shift and go to state 17

    varlist                        shift and go to state 19
    pointer                        shift and go to state 32
    namevar                        shift and go to state 31

state 62

    (21) function_body -> datatype namevar LPAREN RPAREN LBRACE function_content . return_stat RBRACE
    (22) return_stat -> . RETURN pointer SEMICOLON
    (23) return_stat -> . RETURN NAME SEMICOLON
    (24) return_stat -> . RETURN SEMICOLON

    RETURN          shift and go to state 86

    return_stat                    shift and go to state 85

state 63

    (17) arguments -> datatype namevar COMMA . arguments
    (14) arguments -> . datatype pointer
    (15) arguments -> . datatype namevar
    (16) arguments -> . datatype pointer COMMA arguments
    (17) arguments -> . datatype namevar COMMA arguments
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    datatype                       shift and go to state 34
    arguments                      shift and go to state 87

state 64

    (16) arguments -> datatype pointer COMMA . arguments
    (14) arguments -> . datatype pointer
    (15) arguments -> . datatype namevar
    (16) arguments -> . datatype pointer COMMA arguments
    (17) arguments -> . datatype namevar COMMA arguments
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    datatype                       shift and go to state 34
    arguments                      shift and go to state 88

state 65

    (19) function_body -> datatype namevar LPAREN arguments RPAREN LBRACE . function_content return_stat RBRACE
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    while_stat                     shift and go to state 60
    function_content               shift and go to state 89
    datatype                       shift and go to state 61
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 66

    (11) function_dec -> datatype namevar LPAREN arguments RPAREN SEMICOLON .

    VOID            reduce using rule 11 (function_dec -> datatype namevar LPAREN arguments RPAREN SEMICOLON .)
    INT             reduce using rule 11 (function_dec -> datatype namevar LPAREN arguments RPAREN SEMICOLON .)
    FLOAT           reduce using rule 11 (function_dec -> datatype namevar LPAREN arguments RPAREN SEMICOLON .)
    $end            reduce using rule 11 (function_dec -> datatype namevar LPAREN arguments RPAREN SEMICOLON .)


state 67

    (20) function_body -> datatype pointer LPAREN RPAREN LBRACE function_content . return_stat RBRACE
    (22) return_stat -> . RETURN pointer SEMICOLON
    (23) return_stat -> . RETURN NAME SEMICOLON
    (24) return_stat -> . RETURN SEMICOLON

    RETURN          shift and go to state 86

    return_stat                    shift and go to state 90

state 68

    (18) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE . function_content return_stat RBRACE
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    while_stat                     shift and go to state 60
    function_content               shift and go to state 91
    datatype                       shift and go to state 61
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 69

    (10) function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .

    VOID            reduce using rule 10 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)
    INT             reduce using rule 10 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)
    FLOAT           reduce using rule 10 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)
    $end            reduce using rule 10 (function_dec -> datatype pointer LPAREN arguments RPAREN SEMICOLON .)


state 70

    (25) function_call -> NAME LPAREN . varlist RPAREN SEMICOLON
    (26) function_call -> NAME LPAREN . RPAREN SEMICOLON
    (43) varlist -> . namevar COMMA varlist
    (44) varlist -> . pointer COMMA varlist
    (45) varlist -> . namevar
    (46) varlist -> . pointer
    (42) namevar -> . NAME
    (47) pointer -> . ASTERISK pointer
    (48) pointer -> . ASTERISK namevar

    RPAREN          shift and go to state 92
    NAME            shift and go to state 16
    ASTERISK        shift and go to state 17

    varlist                        shift and go to state 93
    pointer                        shift and go to state 32
    namevar                        shift and go to state 31

state 71

    (35) function_content -> function_call function_content .

    RBRACE          reduce using rule 35 (function_content -> function_call function_content .)
    RETURN          reduce using rule 35 (function_content -> function_call function_content .)


state 72

    (73) while_stat -> WHILE LPAREN . b_expression RPAREN code_block
    (76) b_expression -> . expression sign1 expression
    (77) b_expression -> . b_expression sign2 b_expression
    (78) b_expression -> . LPAREN b_expression RPAREN
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 96
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    b_expression                   shift and go to state 95
    NUMBERvar                      shift and go to state 97
    var                            shift and go to state 98
    expression                     shift and go to state 100

state 73

    (32) function_content -> assignment_statement function_content .

    RBRACE          reduce using rule 32 (function_content -> assignment_statement function_content .)
    RETURN          reduce using rule 32 (function_content -> assignment_statement function_content .)


state 74

    (50) assignment_statement -> LEFT EQUAL . expression SEMICOLON
    (52) assignment_statement -> LEFT EQUAL . function_call
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 104
    MINUS           shift and go to state 101
    NAME            shift and go to state 102
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    function_call                  shift and go to state 103
    NUMBERvar                      shift and go to state 97
    var                            shift and go to state 98
    expression                     shift and go to state 105

state 75

    (34) function_content -> if_stat function_content .

    RBRACE          reduce using rule 34 (function_content -> if_stat function_content .)
    RETURN          reduce using rule 34 (function_content -> if_stat function_content .)


state 76

    (54) LEFT -> ASTERISK var .

    EQUAL           reduce using rule 54 (LEFT -> ASTERISK var .)


state 77

    (66) var -> AMPERSAND . var
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME

    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79

    var                            shift and go to state 106

state 78

    (65) var -> ASTERISK . var
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME

    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79

    var                            shift and go to state 107

state 79

    (67) var -> NAME .

    PLUS            reduce using rule 67 (var -> NAME .)
    MINUS           reduce using rule 67 (var -> NAME .)
    ASTERISK        reduce using rule 67 (var -> NAME .)
    DIVIDE          reduce using rule 67 (var -> NAME .)
    RPAREN          reduce using rule 67 (var -> NAME .)
    LOGOR           reduce using rule 67 (var -> NAME .)
    LOGAND          reduce using rule 67 (var -> NAME .)
    EQUALS          reduce using rule 67 (var -> NAME .)
    NOTEQUAL        reduce using rule 67 (var -> NAME .)
    GREATER         reduce using rule 67 (var -> NAME .)
    LESSER          reduce using rule 67 (var -> NAME .)
    GREATEREQ       reduce using rule 67 (var -> NAME .)
    LESSEREQ        reduce using rule 67 (var -> NAME .)
    SEMICOLON       reduce using rule 67 (var -> NAME .)
    EQUAL           reduce using rule 67 (var -> NAME .)


state 80

    (37) function_content -> declaration function_content .

    RBRACE          reduce using rule 37 (function_content -> declaration function_content .)
    RETURN          reduce using rule 37 (function_content -> declaration function_content .)


state 81

    (49) assignment_statement -> ID EQUAL . RIGHT SEMICOLON
    (51) assignment_statement -> ID EQUAL . function_call
    (55) RIGHT -> . AMPERSAND var
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON

    AMPERSAND       shift and go to state 111
    NAME            shift and go to state 109

    RIGHT                          shift and go to state 108
    function_call                  shift and go to state 110

state 82

    (74) if_stat -> IF LPAREN . b_expression RPAREN code_block
    (75) if_stat -> IF LPAREN . b_expression RPAREN code_block ELSE code_block
    (76) b_expression -> . expression sign1 expression
    (77) b_expression -> . b_expression sign2 b_expression
    (78) b_expression -> . LPAREN b_expression RPAREN
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 96
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    b_expression                   shift and go to state 112
    NUMBERvar                      shift and go to state 97
    var                            shift and go to state 98
    expression                     shift and go to state 100

state 83

    (27) program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .

    VOID            reduce using rule 27 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)
    INT             reduce using rule 27 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)
    FLOAT           reduce using rule 27 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)
    $end            reduce using rule 27 (program -> VOID MAIN LPAREN RPAREN LBRACE function_content RBRACE .)


state 84

    (33) function_content -> while_stat function_content .

    RBRACE          reduce using rule 33 (function_content -> while_stat function_content .)
    RETURN          reduce using rule 33 (function_content -> while_stat function_content .)


state 85

    (21) function_body -> datatype namevar LPAREN RPAREN LBRACE function_content return_stat . RBRACE

    RBRACE          shift and go to state 113


state 86

    (22) return_stat -> RETURN . pointer SEMICOLON
    (23) return_stat -> RETURN . NAME SEMICOLON
    (24) return_stat -> RETURN . SEMICOLON
    (47) pointer -> . ASTERISK pointer
    (48) pointer -> . ASTERISK namevar

    NAME            shift and go to state 114
    SEMICOLON       shift and go to state 115
    ASTERISK        shift and go to state 17

    pointer                        shift and go to state 116

state 87

    (17) arguments -> datatype namevar COMMA arguments .

    RPAREN          reduce using rule 17 (arguments -> datatype namevar COMMA arguments .)


state 88

    (16) arguments -> datatype pointer COMMA arguments .

    RPAREN          reduce using rule 16 (arguments -> datatype pointer COMMA arguments .)


state 89

    (19) function_body -> datatype namevar LPAREN arguments RPAREN LBRACE function_content . return_stat RBRACE
    (22) return_stat -> . RETURN pointer SEMICOLON
    (23) return_stat -> . RETURN NAME SEMICOLON
    (24) return_stat -> . RETURN SEMICOLON

    RETURN          shift and go to state 86

    return_stat                    shift and go to state 117

state 90

    (20) function_body -> datatype pointer LPAREN RPAREN LBRACE function_content return_stat . RBRACE

    RBRACE          shift and go to state 118


state 91

    (18) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content . return_stat RBRACE
    (22) return_stat -> . RETURN pointer SEMICOLON
    (23) return_stat -> . RETURN NAME SEMICOLON
    (24) return_stat -> . RETURN SEMICOLON

    RETURN          shift and go to state 86

    return_stat                    shift and go to state 119

state 92

    (26) function_call -> NAME LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 120


state 93

    (25) function_call -> NAME LPAREN varlist . RPAREN SEMICOLON

    RPAREN          shift and go to state 121


state 94

    (63) NUMBERvar -> NUMBER .

    PLUS            reduce using rule 63 (NUMBERvar -> NUMBER .)
    MINUS           reduce using rule 63 (NUMBERvar -> NUMBER .)
    ASTERISK        reduce using rule 63 (NUMBERvar -> NUMBER .)
    DIVIDE          reduce using rule 63 (NUMBERvar -> NUMBER .)
    EQUALS          reduce using rule 63 (NUMBERvar -> NUMBER .)
    NOTEQUAL        reduce using rule 63 (NUMBERvar -> NUMBER .)
    GREATER         reduce using rule 63 (NUMBERvar -> NUMBER .)
    LESSER          reduce using rule 63 (NUMBERvar -> NUMBER .)
    GREATEREQ       reduce using rule 63 (NUMBERvar -> NUMBER .)
    LESSEREQ        reduce using rule 63 (NUMBERvar -> NUMBER .)
    SEMICOLON       reduce using rule 63 (NUMBERvar -> NUMBER .)
    RPAREN          reduce using rule 63 (NUMBERvar -> NUMBER .)
    LOGOR           reduce using rule 63 (NUMBERvar -> NUMBER .)
    LOGAND          reduce using rule 63 (NUMBERvar -> NUMBER .)


state 95

    (73) while_stat -> WHILE LPAREN b_expression . RPAREN code_block
    (77) b_expression -> b_expression . sign2 b_expression
    (85) sign2 -> . LOGOR
    (86) sign2 -> . LOGAND

    RPAREN          shift and go to state 123
    LOGOR           shift and go to state 122
    LOGAND          shift and go to state 124

    sign2                          shift and go to state 125

state 96

    (78) b_expression -> LPAREN . b_expression RPAREN
    (62) expression -> LPAREN . expression RPAREN
    (76) b_expression -> . expression sign1 expression
    (77) b_expression -> . b_expression sign2 b_expression
    (78) b_expression -> . LPAREN b_expression RPAREN
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 96
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    b_expression                   shift and go to state 126
    NUMBERvar                      shift and go to state 97
    var                            shift and go to state 98
    expression                     shift and go to state 127

state 97

    (61) expression -> NUMBERvar .

    RPAREN          reduce using rule 61 (expression -> NUMBERvar .)
    PLUS            reduce using rule 61 (expression -> NUMBERvar .)
    MINUS           reduce using rule 61 (expression -> NUMBERvar .)
    ASTERISK        reduce using rule 61 (expression -> NUMBERvar .)
    DIVIDE          reduce using rule 61 (expression -> NUMBERvar .)
    EQUALS          reduce using rule 61 (expression -> NUMBERvar .)
    NOTEQUAL        reduce using rule 61 (expression -> NUMBERvar .)
    GREATER         reduce using rule 61 (expression -> NUMBERvar .)
    LESSER          reduce using rule 61 (expression -> NUMBERvar .)
    GREATEREQ       reduce using rule 61 (expression -> NUMBERvar .)
    LESSEREQ        reduce using rule 61 (expression -> NUMBERvar .)
    SEMICOLON       reduce using rule 61 (expression -> NUMBERvar .)
    LOGOR           reduce using rule 61 (expression -> NUMBERvar .)
    LOGAND          reduce using rule 61 (expression -> NUMBERvar .)


state 98

    (60) expression -> var .

    RPAREN          reduce using rule 60 (expression -> var .)
    PLUS            reduce using rule 60 (expression -> var .)
    MINUS           reduce using rule 60 (expression -> var .)
    ASTERISK        reduce using rule 60 (expression -> var .)
    DIVIDE          reduce using rule 60 (expression -> var .)
    EQUALS          reduce using rule 60 (expression -> var .)
    NOTEQUAL        reduce using rule 60 (expression -> var .)
    GREATER         reduce using rule 60 (expression -> var .)
    LESSER          reduce using rule 60 (expression -> var .)
    GREATEREQ       reduce using rule 60 (expression -> var .)
    LESSEREQ        reduce using rule 60 (expression -> var .)
    SEMICOLON       reduce using rule 60 (expression -> var .)
    LOGOR           reduce using rule 60 (expression -> var .)
    LOGAND          reduce using rule 60 (expression -> var .)


state 99

    (64) NUMBERvar -> NUMBER2 .

    PLUS            reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    MINUS           reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    ASTERISK        reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    DIVIDE          reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    EQUALS          reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    NOTEQUAL        reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    GREATER         reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    LESSER          reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    GREATEREQ       reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    LESSEREQ        reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    SEMICOLON       reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    RPAREN          reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    LOGOR           reduce using rule 64 (NUMBERvar -> NUMBER2 .)
    LOGAND          reduce using rule 64 (NUMBERvar -> NUMBER2 .)


state 100

    (76) b_expression -> expression . sign1 expression
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression
    (79) sign1 -> . EQUALS
    (80) sign1 -> . NOTEQUAL
    (81) sign1 -> . GREATER
    (82) sign1 -> . LESSER
    (83) sign1 -> . GREATEREQ
    (84) sign1 -> . LESSEREQ

    PLUS            shift and go to state 135
    MINUS           shift and go to state 137
    ASTERISK        shift and go to state 131
    DIVIDE          shift and go to state 129
    EQUALS          shift and go to state 132
    NOTEQUAL        shift and go to state 128
    GREATER         shift and go to state 138
    LESSER          shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEREQ        shift and go to state 130

    sign1                          shift and go to state 136

state 101

    (68) expression -> MINUS . expression
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 104
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    var                            shift and go to state 98
    expression                     shift and go to state 139
    NUMBERvar                      shift and go to state 97

state 102

    (25) function_call -> NAME . LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> NAME . LPAREN RPAREN SEMICOLON
    (67) var -> NAME .

    LPAREN          shift and go to state 70
    SEMICOLON       reduce using rule 67 (var -> NAME .)
    PLUS            reduce using rule 67 (var -> NAME .)
    MINUS           reduce using rule 67 (var -> NAME .)
    ASTERISK        reduce using rule 67 (var -> NAME .)
    DIVIDE          reduce using rule 67 (var -> NAME .)


state 103

    (52) assignment_statement -> LEFT EQUAL function_call .

    WHILE           reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)
    IF              reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)
    NAME            reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)
    ASTERISK        reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)
    INT             reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)
    FLOAT           reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)
    VOID            reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)
    RBRACE          reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)
    RETURN          reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)
    ELSE            reduce using rule 52 (assignment_statement -> LEFT EQUAL function_call .)


state 104

    (62) expression -> LPAREN . expression RPAREN
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 104
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    var                            shift and go to state 98
    expression                     shift and go to state 140
    NUMBERvar                      shift and go to state 97

state 105

    (50) assignment_statement -> LEFT EQUAL expression . SEMICOLON
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 141
    PLUS            shift and go to state 135
    MINUS           shift and go to state 137
    ASTERISK        shift and go to state 131
    DIVIDE          shift and go to state 129


state 106

    (66) var -> AMPERSAND var .

    PLUS            reduce using rule 66 (var -> AMPERSAND var .)
    MINUS           reduce using rule 66 (var -> AMPERSAND var .)
    ASTERISK        reduce using rule 66 (var -> AMPERSAND var .)
    DIVIDE          reduce using rule 66 (var -> AMPERSAND var .)
    RPAREN          reduce using rule 66 (var -> AMPERSAND var .)
    LOGOR           reduce using rule 66 (var -> AMPERSAND var .)
    LOGAND          reduce using rule 66 (var -> AMPERSAND var .)
    EQUALS          reduce using rule 66 (var -> AMPERSAND var .)
    NOTEQUAL        reduce using rule 66 (var -> AMPERSAND var .)
    GREATER         reduce using rule 66 (var -> AMPERSAND var .)
    LESSER          reduce using rule 66 (var -> AMPERSAND var .)
    GREATEREQ       reduce using rule 66 (var -> AMPERSAND var .)
    LESSEREQ        reduce using rule 66 (var -> AMPERSAND var .)
    SEMICOLON       reduce using rule 66 (var -> AMPERSAND var .)
    EQUAL           reduce using rule 66 (var -> AMPERSAND var .)


state 107

    (65) var -> ASTERISK var .

    PLUS            reduce using rule 65 (var -> ASTERISK var .)
    MINUS           reduce using rule 65 (var -> ASTERISK var .)
    ASTERISK        reduce using rule 65 (var -> ASTERISK var .)
    DIVIDE          reduce using rule 65 (var -> ASTERISK var .)
    RPAREN          reduce using rule 65 (var -> ASTERISK var .)
    LOGOR           reduce using rule 65 (var -> ASTERISK var .)
    LOGAND          reduce using rule 65 (var -> ASTERISK var .)
    EQUALS          reduce using rule 65 (var -> ASTERISK var .)
    NOTEQUAL        reduce using rule 65 (var -> ASTERISK var .)
    GREATER         reduce using rule 65 (var -> ASTERISK var .)
    LESSER          reduce using rule 65 (var -> ASTERISK var .)
    GREATEREQ       reduce using rule 65 (var -> ASTERISK var .)
    LESSEREQ        reduce using rule 65 (var -> ASTERISK var .)
    SEMICOLON       reduce using rule 65 (var -> ASTERISK var .)
    EQUAL           reduce using rule 65 (var -> ASTERISK var .)


state 108

    (49) assignment_statement -> ID EQUAL RIGHT . SEMICOLON

    SEMICOLON       shift and go to state 142


state 109

    (25) function_call -> NAME . LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> NAME . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 70


state 110

    (51) assignment_statement -> ID EQUAL function_call .

    WHILE           reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)
    IF              reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)
    NAME            reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)
    ASTERISK        reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)
    INT             reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)
    FLOAT           reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)
    VOID            reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)
    RBRACE          reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)
    RETURN          reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)
    ELSE            reduce using rule 51 (assignment_statement -> ID EQUAL function_call .)


state 111

    (55) RIGHT -> AMPERSAND . var
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME

    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79

    var                            shift and go to state 143

state 112

    (74) if_stat -> IF LPAREN b_expression . RPAREN code_block
    (75) if_stat -> IF LPAREN b_expression . RPAREN code_block ELSE code_block
    (77) b_expression -> b_expression . sign2 b_expression
    (85) sign2 -> . LOGOR
    (86) sign2 -> . LOGAND

    RPAREN          shift and go to state 144
    LOGOR           shift and go to state 122
    LOGAND          shift and go to state 124

    sign2                          shift and go to state 125

state 113

    (21) function_body -> datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE .

    VOID            reduce using rule 21 (function_body -> datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE .)
    INT             reduce using rule 21 (function_body -> datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE .)
    FLOAT           reduce using rule 21 (function_body -> datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE .)
    $end            reduce using rule 21 (function_body -> datatype namevar LPAREN RPAREN LBRACE function_content return_stat RBRACE .)


state 114

    (23) return_stat -> RETURN NAME . SEMICOLON

    SEMICOLON       shift and go to state 145


state 115

    (24) return_stat -> RETURN SEMICOLON .

    RBRACE          reduce using rule 24 (return_stat -> RETURN SEMICOLON .)


state 116

    (22) return_stat -> RETURN pointer . SEMICOLON

    SEMICOLON       shift and go to state 146


state 117

    (19) function_body -> datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat . RBRACE

    RBRACE          shift and go to state 147


state 118

    (20) function_body -> datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE .

    VOID            reduce using rule 20 (function_body -> datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE .)
    INT             reduce using rule 20 (function_body -> datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE .)
    FLOAT           reduce using rule 20 (function_body -> datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE .)
    $end            reduce using rule 20 (function_body -> datatype pointer LPAREN RPAREN LBRACE function_content return_stat RBRACE .)


state 119

    (18) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat . RBRACE

    RBRACE          shift and go to state 148


state 120

    (26) function_call -> NAME LPAREN RPAREN SEMICOLON .

    WHILE           reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    NAME            reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    ASTERISK        reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)
    ELSE            reduce using rule 26 (function_call -> NAME LPAREN RPAREN SEMICOLON .)


state 121

    (25) function_call -> NAME LPAREN varlist RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 149


state 122

    (85) sign2 -> LOGOR .

    LPAREN          reduce using rule 85 (sign2 -> LOGOR .)
    MINUS           reduce using rule 85 (sign2 -> LOGOR .)
    ASTERISK        reduce using rule 85 (sign2 -> LOGOR .)
    AMPERSAND       reduce using rule 85 (sign2 -> LOGOR .)
    NAME            reduce using rule 85 (sign2 -> LOGOR .)
    NUMBER          reduce using rule 85 (sign2 -> LOGOR .)
    NUMBER2         reduce using rule 85 (sign2 -> LOGOR .)


state 123

    (73) while_stat -> WHILE LPAREN b_expression RPAREN . code_block
    (69) code_block -> . if_stat
    (70) code_block -> . while_stat
    (71) code_block -> . assignment_statement
    (72) code_block -> . LBRACE function_content RBRACE
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var

    LBRACE          shift and go to state 150
    IF              shift and go to state 58
    WHILE           shift and go to state 51
    NAME            shift and go to state 153
    ASTERISK        shift and go to state 55

    code_block                     shift and go to state 154
    while_stat                     shift and go to state 155
    if_stat                        shift and go to state 152
    assignment_statement           shift and go to state 151
    LEFT                           shift and go to state 53
    ID                             shift and go to state 57

state 124

    (86) sign2 -> LOGAND .

    LPAREN          reduce using rule 86 (sign2 -> LOGAND .)
    MINUS           reduce using rule 86 (sign2 -> LOGAND .)
    ASTERISK        reduce using rule 86 (sign2 -> LOGAND .)
    AMPERSAND       reduce using rule 86 (sign2 -> LOGAND .)
    NAME            reduce using rule 86 (sign2 -> LOGAND .)
    NUMBER          reduce using rule 86 (sign2 -> LOGAND .)
    NUMBER2         reduce using rule 86 (sign2 -> LOGAND .)


state 125

    (77) b_expression -> b_expression sign2 . b_expression
    (76) b_expression -> . expression sign1 expression
    (77) b_expression -> . b_expression sign2 b_expression
    (78) b_expression -> . LPAREN b_expression RPAREN
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 96
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    b_expression                   shift and go to state 156
    NUMBERvar                      shift and go to state 97
    var                            shift and go to state 98
    expression                     shift and go to state 100

state 126

    (78) b_expression -> LPAREN b_expression . RPAREN
    (77) b_expression -> b_expression . sign2 b_expression
    (85) sign2 -> . LOGOR
    (86) sign2 -> . LOGAND

    RPAREN          shift and go to state 157
    LOGOR           shift and go to state 122
    LOGAND          shift and go to state 124

    sign2                          shift and go to state 125

state 127

    (62) expression -> LPAREN expression . RPAREN
    (76) b_expression -> expression . sign1 expression
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression
    (79) sign1 -> . EQUALS
    (80) sign1 -> . NOTEQUAL
    (81) sign1 -> . GREATER
    (82) sign1 -> . LESSER
    (83) sign1 -> . GREATEREQ
    (84) sign1 -> . LESSEREQ

    RPAREN          shift and go to state 158
    PLUS            shift and go to state 135
    MINUS           shift and go to state 137
    ASTERISK        shift and go to state 131
    DIVIDE          shift and go to state 129
    EQUALS          shift and go to state 132
    NOTEQUAL        shift and go to state 128
    GREATER         shift and go to state 138
    LESSER          shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEREQ        shift and go to state 130

    sign1                          shift and go to state 136

state 128

    (80) sign1 -> NOTEQUAL .

    LPAREN          reduce using rule 80 (sign1 -> NOTEQUAL .)
    MINUS           reduce using rule 80 (sign1 -> NOTEQUAL .)
    ASTERISK        reduce using rule 80 (sign1 -> NOTEQUAL .)
    AMPERSAND       reduce using rule 80 (sign1 -> NOTEQUAL .)
    NAME            reduce using rule 80 (sign1 -> NOTEQUAL .)
    NUMBER          reduce using rule 80 (sign1 -> NOTEQUAL .)
    NUMBER2         reduce using rule 80 (sign1 -> NOTEQUAL .)


state 129

    (59) expression -> expression DIVIDE . expression
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 104
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    var                            shift and go to state 98
    expression                     shift and go to state 159
    NUMBERvar                      shift and go to state 97

state 130

    (84) sign1 -> LESSEREQ .

    LPAREN          reduce using rule 84 (sign1 -> LESSEREQ .)
    MINUS           reduce using rule 84 (sign1 -> LESSEREQ .)
    ASTERISK        reduce using rule 84 (sign1 -> LESSEREQ .)
    AMPERSAND       reduce using rule 84 (sign1 -> LESSEREQ .)
    NAME            reduce using rule 84 (sign1 -> LESSEREQ .)
    NUMBER          reduce using rule 84 (sign1 -> LESSEREQ .)
    NUMBER2         reduce using rule 84 (sign1 -> LESSEREQ .)


state 131

    (58) expression -> expression ASTERISK . expression
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 104
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    var                            shift and go to state 98
    expression                     shift and go to state 160
    NUMBERvar                      shift and go to state 97

state 132

    (79) sign1 -> EQUALS .

    LPAREN          reduce using rule 79 (sign1 -> EQUALS .)
    MINUS           reduce using rule 79 (sign1 -> EQUALS .)
    ASTERISK        reduce using rule 79 (sign1 -> EQUALS .)
    AMPERSAND       reduce using rule 79 (sign1 -> EQUALS .)
    NAME            reduce using rule 79 (sign1 -> EQUALS .)
    NUMBER          reduce using rule 79 (sign1 -> EQUALS .)
    NUMBER2         reduce using rule 79 (sign1 -> EQUALS .)


state 133

    (82) sign1 -> LESSER .

    LPAREN          reduce using rule 82 (sign1 -> LESSER .)
    MINUS           reduce using rule 82 (sign1 -> LESSER .)
    ASTERISK        reduce using rule 82 (sign1 -> LESSER .)
    AMPERSAND       reduce using rule 82 (sign1 -> LESSER .)
    NAME            reduce using rule 82 (sign1 -> LESSER .)
    NUMBER          reduce using rule 82 (sign1 -> LESSER .)
    NUMBER2         reduce using rule 82 (sign1 -> LESSER .)


state 134

    (83) sign1 -> GREATEREQ .

    LPAREN          reduce using rule 83 (sign1 -> GREATEREQ .)
    MINUS           reduce using rule 83 (sign1 -> GREATEREQ .)
    ASTERISK        reduce using rule 83 (sign1 -> GREATEREQ .)
    AMPERSAND       reduce using rule 83 (sign1 -> GREATEREQ .)
    NAME            reduce using rule 83 (sign1 -> GREATEREQ .)
    NUMBER          reduce using rule 83 (sign1 -> GREATEREQ .)
    NUMBER2         reduce using rule 83 (sign1 -> GREATEREQ .)


state 135

    (56) expression -> expression PLUS . expression
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 104
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    var                            shift and go to state 98
    expression                     shift and go to state 161
    NUMBERvar                      shift and go to state 97

state 136

    (76) b_expression -> expression sign1 . expression
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 104
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    var                            shift and go to state 98
    expression                     shift and go to state 162
    NUMBERvar                      shift and go to state 97

state 137

    (57) expression -> expression MINUS . expression
    (56) expression -> . expression PLUS expression
    (57) expression -> . expression MINUS expression
    (58) expression -> . expression ASTERISK expression
    (59) expression -> . expression DIVIDE expression
    (60) expression -> . var
    (61) expression -> . NUMBERvar
    (62) expression -> . LPAREN expression RPAREN
    (68) expression -> . MINUS expression
    (65) var -> . ASTERISK var
    (66) var -> . AMPERSAND var
    (67) var -> . NAME
    (63) NUMBERvar -> . NUMBER
    (64) NUMBERvar -> . NUMBER2

    LPAREN          shift and go to state 104
    MINUS           shift and go to state 101
    ASTERISK        shift and go to state 78
    AMPERSAND       shift and go to state 77
    NAME            shift and go to state 79
    NUMBER          shift and go to state 94
    NUMBER2         shift and go to state 99

    var                            shift and go to state 98
    expression                     shift and go to state 163
    NUMBERvar                      shift and go to state 97

state 138

    (81) sign1 -> GREATER .

    LPAREN          reduce using rule 81 (sign1 -> GREATER .)
    MINUS           reduce using rule 81 (sign1 -> GREATER .)
    ASTERISK        reduce using rule 81 (sign1 -> GREATER .)
    AMPERSAND       reduce using rule 81 (sign1 -> GREATER .)
    NAME            reduce using rule 81 (sign1 -> GREATER .)
    NUMBER          reduce using rule 81 (sign1 -> GREATER .)
    NUMBER2         reduce using rule 81 (sign1 -> GREATER .)


state 139

    (68) expression -> MINUS expression .
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 68 (expression -> MINUS expression .)
    PLUS            reduce using rule 68 (expression -> MINUS expression .)
    MINUS           reduce using rule 68 (expression -> MINUS expression .)
    ASTERISK        reduce using rule 68 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 68 (expression -> MINUS expression .)
    EQUALS          reduce using rule 68 (expression -> MINUS expression .)
    NOTEQUAL        reduce using rule 68 (expression -> MINUS expression .)
    GREATER         reduce using rule 68 (expression -> MINUS expression .)
    LESSER          reduce using rule 68 (expression -> MINUS expression .)
    GREATEREQ       reduce using rule 68 (expression -> MINUS expression .)
    LESSEREQ        reduce using rule 68 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 68 (expression -> MINUS expression .)
    LOGOR           reduce using rule 68 (expression -> MINUS expression .)
    LOGAND          reduce using rule 68 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 135 ]
  ! MINUS           [ shift and go to state 137 ]
  ! ASTERISK        [ shift and go to state 131 ]
  ! DIVIDE          [ shift and go to state 129 ]


state 140

    (62) expression -> LPAREN expression . RPAREN
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 158
    PLUS            shift and go to state 135
    MINUS           shift and go to state 137
    ASTERISK        shift and go to state 131
    DIVIDE          shift and go to state 129


state 141

    (50) assignment_statement -> LEFT EQUAL expression SEMICOLON .

    WHILE           reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    IF              reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    NAME            reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    ASTERISK        reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    INT             reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    VOID            reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)
    ELSE            reduce using rule 50 (assignment_statement -> LEFT EQUAL expression SEMICOLON .)


state 142

    (49) assignment_statement -> ID EQUAL RIGHT SEMICOLON .

    WHILE           reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    IF              reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    NAME            reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    ASTERISK        reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    INT             reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    FLOAT           reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    VOID            reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    RBRACE          reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    RETURN          reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)
    ELSE            reduce using rule 49 (assignment_statement -> ID EQUAL RIGHT SEMICOLON .)


state 143

    (55) RIGHT -> AMPERSAND var .

    SEMICOLON       reduce using rule 55 (RIGHT -> AMPERSAND var .)


state 144

    (74) if_stat -> IF LPAREN b_expression RPAREN . code_block
    (75) if_stat -> IF LPAREN b_expression RPAREN . code_block ELSE code_block
    (69) code_block -> . if_stat
    (70) code_block -> . while_stat
    (71) code_block -> . assignment_statement
    (72) code_block -> . LBRACE function_content RBRACE
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var

    LBRACE          shift and go to state 150
    IF              shift and go to state 58
    WHILE           shift and go to state 51
    NAME            shift and go to state 153
    ASTERISK        shift and go to state 55

    code_block                     shift and go to state 164
    while_stat                     shift and go to state 155
    if_stat                        shift and go to state 152
    assignment_statement           shift and go to state 151
    LEFT                           shift and go to state 53
    ID                             shift and go to state 57

state 145

    (23) return_stat -> RETURN NAME SEMICOLON .

    RBRACE          reduce using rule 23 (return_stat -> RETURN NAME SEMICOLON .)


state 146

    (22) return_stat -> RETURN pointer SEMICOLON .

    RBRACE          reduce using rule 22 (return_stat -> RETURN pointer SEMICOLON .)


state 147

    (19) function_body -> datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .

    VOID            reduce using rule 19 (function_body -> datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    INT             reduce using rule 19 (function_body -> datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    FLOAT           reduce using rule 19 (function_body -> datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    $end            reduce using rule 19 (function_body -> datatype namevar LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)


state 148

    (18) function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .

    VOID            reduce using rule 18 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    INT             reduce using rule 18 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    FLOAT           reduce using rule 18 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)
    $end            reduce using rule 18 (function_body -> datatype pointer LPAREN arguments RPAREN LBRACE function_content return_stat RBRACE .)


state 149

    (25) function_call -> NAME LPAREN varlist RPAREN SEMICOLON .

    WHILE           reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    IF              reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    NAME            reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    ASTERISK        reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    INT             reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    FLOAT           reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    VOID            reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    RETURN          reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    RBRACE          reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)
    ELSE            reduce using rule 25 (function_call -> NAME LPAREN varlist RPAREN SEMICOLON .)


state 150

    (72) code_block -> LBRACE . function_content RBRACE
    (28) function_content -> . assignment_statement
    (29) function_content -> . while_stat
    (30) function_content -> . if_stat
    (31) function_content -> . function_call
    (32) function_content -> . assignment_statement function_content
    (33) function_content -> . while_stat function_content
    (34) function_content -> . if_stat function_content
    (35) function_content -> . function_call function_content
    (36) function_content -> . declaration
    (37) function_content -> . declaration function_content
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (25) function_call -> . NAME LPAREN varlist RPAREN SEMICOLON
    (26) function_call -> . NAME LPAREN RPAREN SEMICOLON
    (38) declaration -> . datatype varlist SEMICOLON
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var
    (39) datatype -> . INT
    (40) datatype -> . FLOAT
    (41) datatype -> . VOID

    WHILE           shift and go to state 51
    IF              shift and go to state 58
    NAME            shift and go to state 49
    ASTERISK        shift and go to state 55
    INT             shift and go to state 10
    FLOAT           shift and go to state 9
    VOID            shift and go to state 35

    function_content               shift and go to state 165
    while_stat                     shift and go to state 60
    if_stat                        shift and go to state 54
    assignment_statement           shift and go to state 52
    function_call                  shift and go to state 50
    datatype                       shift and go to state 61
    declaration                    shift and go to state 56
    ID                             shift and go to state 57
    LEFT                           shift and go to state 53

state 151

    (71) code_block -> assignment_statement .

    WHILE           reduce using rule 71 (code_block -> assignment_statement .)
    IF              reduce using rule 71 (code_block -> assignment_statement .)
    NAME            reduce using rule 71 (code_block -> assignment_statement .)
    ASTERISK        reduce using rule 71 (code_block -> assignment_statement .)
    INT             reduce using rule 71 (code_block -> assignment_statement .)
    FLOAT           reduce using rule 71 (code_block -> assignment_statement .)
    VOID            reduce using rule 71 (code_block -> assignment_statement .)
    RBRACE          reduce using rule 71 (code_block -> assignment_statement .)
    RETURN          reduce using rule 71 (code_block -> assignment_statement .)
    ELSE            reduce using rule 71 (code_block -> assignment_statement .)


state 152

    (69) code_block -> if_stat .

    WHILE           reduce using rule 69 (code_block -> if_stat .)
    IF              reduce using rule 69 (code_block -> if_stat .)
    NAME            reduce using rule 69 (code_block -> if_stat .)
    ASTERISK        reduce using rule 69 (code_block -> if_stat .)
    INT             reduce using rule 69 (code_block -> if_stat .)
    FLOAT           reduce using rule 69 (code_block -> if_stat .)
    VOID            reduce using rule 69 (code_block -> if_stat .)
    RBRACE          reduce using rule 69 (code_block -> if_stat .)
    RETURN          reduce using rule 69 (code_block -> if_stat .)
    ELSE            reduce using rule 69 (code_block -> if_stat .)


state 153

    (53) ID -> NAME .

    EQUAL           reduce using rule 53 (ID -> NAME .)


state 154

    (73) while_stat -> WHILE LPAREN b_expression RPAREN code_block .

    WHILE           reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    IF              reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    NAME            reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    ASTERISK        reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    INT             reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    FLOAT           reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    VOID            reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    RBRACE          reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    RETURN          reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)
    ELSE            reduce using rule 73 (while_stat -> WHILE LPAREN b_expression RPAREN code_block .)


state 155

    (70) code_block -> while_stat .

    WHILE           reduce using rule 70 (code_block -> while_stat .)
    IF              reduce using rule 70 (code_block -> while_stat .)
    NAME            reduce using rule 70 (code_block -> while_stat .)
    ASTERISK        reduce using rule 70 (code_block -> while_stat .)
    INT             reduce using rule 70 (code_block -> while_stat .)
    FLOAT           reduce using rule 70 (code_block -> while_stat .)
    VOID            reduce using rule 70 (code_block -> while_stat .)
    RBRACE          reduce using rule 70 (code_block -> while_stat .)
    RETURN          reduce using rule 70 (code_block -> while_stat .)
    ELSE            reduce using rule 70 (code_block -> while_stat .)


state 156

    (77) b_expression -> b_expression sign2 b_expression .
    (77) b_expression -> b_expression . sign2 b_expression
    (85) sign2 -> . LOGOR
    (86) sign2 -> . LOGAND

  ! shift/reduce conflict for LOGOR resolved as shift
  ! shift/reduce conflict for LOGAND resolved as shift
    RPAREN          reduce using rule 77 (b_expression -> b_expression sign2 b_expression .)
    LOGOR           shift and go to state 122
    LOGAND          shift and go to state 124

  ! LOGOR           [ reduce using rule 77 (b_expression -> b_expression sign2 b_expression .) ]
  ! LOGAND          [ reduce using rule 77 (b_expression -> b_expression sign2 b_expression .) ]

    sign2                          shift and go to state 125

state 157

    (78) b_expression -> LPAREN b_expression RPAREN .

    RPAREN          reduce using rule 78 (b_expression -> LPAREN b_expression RPAREN .)
    LOGOR           reduce using rule 78 (b_expression -> LPAREN b_expression RPAREN .)
    LOGAND          reduce using rule 78 (b_expression -> LPAREN b_expression RPAREN .)


state 158

    (62) expression -> LPAREN expression RPAREN .

    RPAREN          reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    ASTERISK        reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    EQUALS          reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    LESSER          reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    LESSEREQ        reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    LOGOR           reduce using rule 62 (expression -> LPAREN expression RPAREN .)
    LOGAND          reduce using rule 62 (expression -> LPAREN expression RPAREN .)


state 159

    (59) expression -> expression DIVIDE expression .
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 59 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 59 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 59 (expression -> expression DIVIDE expression .)
    ASTERISK        reduce using rule 59 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 59 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 59 (expression -> expression DIVIDE expression .)
    NOTEQUAL        reduce using rule 59 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 59 (expression -> expression DIVIDE expression .)
    LESSER          reduce using rule 59 (expression -> expression DIVIDE expression .)
    GREATEREQ       reduce using rule 59 (expression -> expression DIVIDE expression .)
    LESSEREQ        reduce using rule 59 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 59 (expression -> expression DIVIDE expression .)
    LOGOR           reduce using rule 59 (expression -> expression DIVIDE expression .)
    LOGAND          reduce using rule 59 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 135 ]
  ! MINUS           [ shift and go to state 137 ]
  ! ASTERISK        [ shift and go to state 131 ]
  ! DIVIDE          [ shift and go to state 129 ]


state 160

    (58) expression -> expression ASTERISK expression .
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 58 (expression -> expression ASTERISK expression .)
    PLUS            reduce using rule 58 (expression -> expression ASTERISK expression .)
    MINUS           reduce using rule 58 (expression -> expression ASTERISK expression .)
    ASTERISK        reduce using rule 58 (expression -> expression ASTERISK expression .)
    DIVIDE          reduce using rule 58 (expression -> expression ASTERISK expression .)
    EQUALS          reduce using rule 58 (expression -> expression ASTERISK expression .)
    NOTEQUAL        reduce using rule 58 (expression -> expression ASTERISK expression .)
    GREATER         reduce using rule 58 (expression -> expression ASTERISK expression .)
    LESSER          reduce using rule 58 (expression -> expression ASTERISK expression .)
    GREATEREQ       reduce using rule 58 (expression -> expression ASTERISK expression .)
    LESSEREQ        reduce using rule 58 (expression -> expression ASTERISK expression .)
    SEMICOLON       reduce using rule 58 (expression -> expression ASTERISK expression .)
    LOGOR           reduce using rule 58 (expression -> expression ASTERISK expression .)
    LOGAND          reduce using rule 58 (expression -> expression ASTERISK expression .)

  ! PLUS            [ shift and go to state 135 ]
  ! MINUS           [ shift and go to state 137 ]
  ! ASTERISK        [ shift and go to state 131 ]
  ! DIVIDE          [ shift and go to state 129 ]


state 161

    (56) expression -> expression PLUS expression .
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 56 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 56 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 56 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 56 (expression -> expression PLUS expression .)
    NOTEQUAL        reduce using rule 56 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 56 (expression -> expression PLUS expression .)
    LESSER          reduce using rule 56 (expression -> expression PLUS expression .)
    GREATEREQ       reduce using rule 56 (expression -> expression PLUS expression .)
    LESSEREQ        reduce using rule 56 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 56 (expression -> expression PLUS expression .)
    LOGOR           reduce using rule 56 (expression -> expression PLUS expression .)
    LOGAND          reduce using rule 56 (expression -> expression PLUS expression .)
    ASTERISK        shift and go to state 131
    DIVIDE          shift and go to state 129

  ! ASTERISK        [ reduce using rule 56 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 56 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 135 ]
  ! MINUS           [ shift and go to state 137 ]


state 162

    (76) b_expression -> expression sign1 expression .
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 76 (b_expression -> expression sign1 expression .)
    LOGOR           reduce using rule 76 (b_expression -> expression sign1 expression .)
    LOGAND          reduce using rule 76 (b_expression -> expression sign1 expression .)
    PLUS            shift and go to state 135
    MINUS           shift and go to state 137
    ASTERISK        shift and go to state 131
    DIVIDE          shift and go to state 129


state 163

    (57) expression -> expression MINUS expression .
    (56) expression -> expression . PLUS expression
    (57) expression -> expression . MINUS expression
    (58) expression -> expression . ASTERISK expression
    (59) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 57 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 57 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 57 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 57 (expression -> expression MINUS expression .)
    NOTEQUAL        reduce using rule 57 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 57 (expression -> expression MINUS expression .)
    LESSER          reduce using rule 57 (expression -> expression MINUS expression .)
    GREATEREQ       reduce using rule 57 (expression -> expression MINUS expression .)
    LESSEREQ        reduce using rule 57 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 57 (expression -> expression MINUS expression .)
    LOGOR           reduce using rule 57 (expression -> expression MINUS expression .)
    LOGAND          reduce using rule 57 (expression -> expression MINUS expression .)
    ASTERISK        shift and go to state 131
    DIVIDE          shift and go to state 129

  ! ASTERISK        [ reduce using rule 57 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 57 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 135 ]
  ! MINUS           [ shift and go to state 137 ]


state 164

    (74) if_stat -> IF LPAREN b_expression RPAREN code_block .
    (75) if_stat -> IF LPAREN b_expression RPAREN code_block . ELSE code_block

    WHILE           reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    IF              reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    NAME            reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    ASTERISK        reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    INT             reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    FLOAT           reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    VOID            reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    RBRACE          reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    RETURN          reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .)
    ELSE            shift and go to state 166

  ! ELSE            [ reduce using rule 74 (if_stat -> IF LPAREN b_expression RPAREN code_block .) ]


state 165

    (72) code_block -> LBRACE function_content . RBRACE

    RBRACE          shift and go to state 167


state 166

    (75) if_stat -> IF LPAREN b_expression RPAREN code_block ELSE . code_block
    (69) code_block -> . if_stat
    (70) code_block -> . while_stat
    (71) code_block -> . assignment_statement
    (72) code_block -> . LBRACE function_content RBRACE
    (74) if_stat -> . IF LPAREN b_expression RPAREN code_block
    (75) if_stat -> . IF LPAREN b_expression RPAREN code_block ELSE code_block
    (73) while_stat -> . WHILE LPAREN b_expression RPAREN code_block
    (49) assignment_statement -> . ID EQUAL RIGHT SEMICOLON
    (50) assignment_statement -> . LEFT EQUAL expression SEMICOLON
    (51) assignment_statement -> . ID EQUAL function_call
    (52) assignment_statement -> . LEFT EQUAL function_call
    (53) ID -> . NAME
    (54) LEFT -> . ASTERISK var

    LBRACE          shift and go to state 150
    IF              shift and go to state 58
    WHILE           shift and go to state 51
    NAME            shift and go to state 153
    ASTERISK        shift and go to state 55

    code_block                     shift and go to state 168
    while_stat                     shift and go to state 155
    if_stat                        shift and go to state 152
    assignment_statement           shift and go to state 151
    LEFT                           shift and go to state 53
    ID                             shift and go to state 57

state 167

    (72) code_block -> LBRACE function_content RBRACE .

    WHILE           reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)
    IF              reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)
    NAME            reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)
    ASTERISK        reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)
    INT             reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)
    FLOAT           reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)
    VOID            reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)
    RBRACE          reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)
    RETURN          reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)
    ELSE            reduce using rule 72 (code_block -> LBRACE function_content RBRACE .)


state 168

    (75) if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .

    WHILE           reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    IF              reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    NAME            reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    ASTERISK        reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    INT             reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    FLOAT           reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    VOID            reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    RBRACE          reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    RETURN          reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)
    ELSE            reduce using rule 75 (if_stat -> IF LPAREN b_expression RPAREN code_block ELSE code_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOGOR in state 156 resolved as shift
WARNING: shift/reduce conflict for LOGAND in state 156 resolved as shift
